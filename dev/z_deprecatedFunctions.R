

#' @title checkQC_old
#' @description Function to check QC samples in \code{rawData}.
#' 
#' @param rawQC An \linkS4class{OnDiskMSnExp} object corresponding to the QC samples.
#' The function \code{filterFile} from \code{MSnbase} can be used to subset the \code{rawData}, such as \code{MSnbase::filterFile(rawData, file = 4:6)}.
#' @param sampleInfo The \code{sampleInfo} data frame generated by \code{\link{setupProject}} function.
#' @param screeningList A \code{data.frame} with details from each standard in the QC samples.
#' See details for more information about the required data.frame structure.
#' @param paramPeaks The parameters for the choosen peak picking method.
#' See documentation of \code{\link[xcms]{chromatographic-peak-detection}} for more information. 
#' @param paramPreGrouping If \code{\link[xcms]{adjustRtime}} is preformed with the method \code{PeakGroups},
#' a pre-grouping of peaks is required for alignment. The \code{paramPreGrouping} is the parameters obtained by the selected grouping method.
#' See documentation of \code{\link[xcms]{groupChromPeaks}} for more information.
#' @param paramAlignment The parameters for the choosen alignment method. See documentation of \code{\link[xcms]{adjustRtime}} for more information.
#' @param paramGrouping The parameters for the choosen grouping method.
#' See documentation of \code{\link[xcms]{groupChromPeaks}} for more information.
#' @param ppmForFillingGroups The mass (in ppm) to expand the \emph{mz} for filling missing peaks in imcomplete features.
#' See \code{\link[xcms]{fillChromPeaks}} for more information.
#' @param rtWindow The retention time deviation, in seconds, allowed to screen for QC reference standards.
#' @param ppmWindow The mass deviation, in ppm, allowed to screen for QC reference standards.
#' @param polarity The acquisition polarity of the QC samples. Possible values are \code{positive} or \code{negative}.
#' @param plot Logical, set to \code{TRUE} for plotting the results.
#' @param save Logical, set to \code{TRUE} for storing  the generated QC object in the rData folder. 
#' @param projPath The \code{projPath} directory as defined in the \code{setup} object.
#'
#' @details The \code{screeningList} template can be obtained as csv via \code{ntsIUTA::getScreeningListTemplate()}.
#' Add other details of the template.
#'
#' @return A \code{list} containing the plots and a data.frame with the summary of the
#' retention time, mass and intensity deviations as well as the quality of the MS2 data.
#' 
#' @export
#'
#' @import magrittr
#' @importFrom utils read.csv write.csv
#' @importFrom patRoon screenSuspects screenInfo getDefAvgPListParams generateMSPeakLists as.data.table
#' @importFrom dplyr select arrange left_join everything filter mutate top_n
#' @importFrom fuzzyjoin difference_inner_join
#' @importFrom stats cor
#' @importFrom gridExtra arrangeGrob
#' @import ggplot2
#' @importFrom htmlwidgets saveWidget
#' @importFrom plotly partial_bundle
#' @importFrom xcms applyAdjustedRtime
#'
#'
#' @examples
#' 
#' 
#' 
checkQC_old <- function(rawQC = rawData,
                        sampleInfo = setup$sampleInfo,
                        screeningList = utils::choose.files(base::getwd(), "Select the QC screening list"),
                        paramPeaks = NULL,
                        paramPreGrouping = NULL,
                        paramAlignment = NULL,
                        paramGrouping = NULL,
                        ppmForFillingGroups = 5,
                        rtWindow = 30,
                        ppmWindow = 15,
                        polarity = "positive",
                        plot = TRUE,
                        save = FALSE, projPath = setup$projPath) {
  
  # rawQC = MSnbase::filterFile(rawData, file = 4:6)
  # sampleInfo = setup$sampleInfo
  # screeningList = base::paste0(system.file(package = "ntsIUTA", dir = "extdata"),"/QC_ScreeningList_ntsIUTA_MS2_pos.csv")
  # paramPeaks = param
  # paramPreGrouping = param1
  # paramAlignment = param2
  # paramGrouping = param3
  # ppmForFillingGroups = 5
  # rtWindow = 30
  # ppmWindow = 15
  # polarity = "positive"
  # plot = TRUE
  # save = TRUE
  
  if (base::is.null(rawQC)) stop("rawData of QC samples should be provided using the argument rawQC. See ?checkQC for more information.")
  
  
  qcPeaks <- ntsIUTA::peakPicking(rawQC,
                                  param = paramPeaks,
                                  removeQC = FALSE,
                                  refinePeaks = FALSE,
                                  save = FALSE)
  
  qcFeat <- ntsIUTA::makeFeatures(peaksData = qcPeaks,
                                  paramPreGrouping = paramPreGrouping,
                                  paramAlignment = paramAlignment,
                                  paramGrouping = paramGrouping,
                                  ppmForFillingGroups = ppmForFillingGroups,
                                  save = FALSE)
  
  if (plot) {
    alignPlot <- ntsIUTA::plotAlignment(qcFeat)
  }
  
  qcFeat <- xcms::applyAdjustedRtime(qcFeat)
  
  qcPat <- ntsIUTA::getPatData(qcFeat, sampleInfo = sampleInfo[sampleInfo$sample %in% qcFeat$sample_name,])
  
  #load or read screeningList
  if (!base::is.data.frame(screeningList)) {
    sl <- utils::read.csv(screeningList)
  } else {
    sl <- screeningList
  }
  if (base::max(sl$rt) < 120) sl$rt <- sl$rt * 60
  
  #check polarity
  if (base::length(polarity) == 1 & !base::is.null(polarity)) {
    adduct <- base::ifelse(polarity == "positive", "[M+H]+", base::ifelse(polarity == "negative", "[M-H]-", stop("polarity argument must be 'positive' or 'negative'")))
  } else {
    stop("polarity argument must be 'positive' or 'negative'")
  }
  
  qcID <- patRoon::screenSuspects(qcPat, dplyr::select(sl, -mz), rtWindow = rtWindow, mzWindow = 0.01, adduct = adduct, onlyHits = TRUE)
  qcdf <- dplyr::arrange(patRoon::as.data.table(qcID, average = FALSE), group)
  qcdf <- dplyr::left_join(qcdf, sl[,base::c("name", "formula", "int10", "hasMS2", "mzMS2", "intMS2", "preMS2")], by = "name")
  qcdf  <- dplyr::left_join(qcdf, dplyr::select(dplyr::arrange(patRoon::screenInfo(qcID), group), group, d_mz, d_rt), by = "group")
  qcdf$av_into <- base::rowMeans(dplyr::select(qcdf, rawQC$sample_name))
  qcdf <- qcdf %>% dplyr::mutate(sd_into = base::apply(dplyr::select(., rawQC$sample_name), 1, sd))
  qcdf <- dplyr::mutate(qcdf, sd_intop = sd_into/av_into*100)
  qcdf$d_ppm <- (base::abs(qcdf$d_mz)/qcdf$mz)*1E6
  qcdf <- dplyr::select(qcdf, name, formula, d_ppm, d_rt, mz, ret, group, dplyr::everything(), -d_mz)
  qcdf<- dplyr::filter(qcdf, d_ppm <= ppmWindow)
  qcdf <- base::as.data.frame(qcdf)
  
  
  control_avgPListParams <- patRoon::getDefAvgPListParams(
    clusterMzWindow = 0.005,
    topMost = 50,
    minIntensityPre = 10,
    minIntensityPost = 10
  )
  
  MS2 <- base::suppressWarnings(patRoon::generateMSPeakLists(
    qcID, "mzr",
    maxMSRtWindow = 5,
    precursorMzWindow = 3,
    avgFeatParams = control_avgPListParams, 
    avgFGroupParams = control_avgPListParams
  ))
  
  
  #add MS2 to screening list, adds intensity at 10ng/ml to respective column and adds mz corresponding to the polarity for MS2 matching
  # for (i in 1:base::nrow(qcdf)) {
  #   xgroup <- qcdf$group[i]
  #   xfrag <- MS2[[xgroup]]$MSMS
  # 
  #   if (!base::is.null(xfrag)) {
  #     sl$hasMS2[sl$name %in% qcdf$name[i]] <- TRUE
  #     sl$mzMS2[sl$name %in% qcdf$name[i]] <- base::paste(xfrag$mz, collapse = ";")
  #     sl$intMS2[sl$name %in% qcdf$name[i]] <- base::paste(xfrag$intensity, collapse = ";")
  #     sl$preMS2[sl$name %in% qcdf$name[i]] <- base::paste(xfrag$precursor, collapse = ";")
  #   }
  # 
  #   sl$int10[sl$name %in% qcdf$name[i]] <- qcdf$av_into[i]
  #   sl$rt[sl$name %in% qcdf$name[i]] <- qcdf$ret[i]/60
  #   sl$mz[sl$name %in% qcdf$name[i]] <- sl$neutralMass[sl$name %in% qcdf$name[i]] +  base::ifelse(polarity == "positive", 1.007276, -1.007276)
  # }
  # 
  # utils::write.csv(sl, file = base::paste0(projPath,"/ScreeningList_QC_ntsIUTA_MS2_pos.csv"))
  
  qcdf$nfrag <- 0
  qcdf$pfrag <- 0
  qcdf$intoscore <- 0
  
  for (i in 1:base::nrow(qcdf)) {
    xgroup <- qcdf$group[i]
    xname <- qcdf$name[i]
    if (!base::is.na(xgroup) & qcdf$hasMS2[i]) {
      xMS2 <- MS2[[xgroup]]$MSMS
      if (!base::is.null(xMS2)) {
        dbMS2 <- base::data.frame(mz = base::as.numeric(base::unlist(base::strsplit(qcdf$mzMS2[i], split=";"))),
                                  intensity = base::as.numeric(base::unlist(base::strsplit(qcdf$intMS2[i], split=";"))),
                                  precursor = base::as.logical(base::unlist(base::strsplit(qcdf$preMS2[i], split=";"))))
        
        xMS2 <- dplyr::top_n(xMS2, 10, intensity)
        xMS2 <- dplyr::mutate(xMS2, into_ind = intensity/base::max(xMS2$intensity))
        
        dbMS2 <- dplyr::top_n(dbMS2, 10, intensity)
        dbMS2 <- dplyr::mutate(dbMS2, into_ind = intensity/base::max(dbMS2$intensity))
        
        combi <- fuzzyjoin::difference_inner_join(xMS2, dbMS2, by = c("mz"), max_dist = 0.005, distance_col = "diff")
        
        qcdf$nfrag[i] <- base::nrow(combi)
        qcdf$pfrag[i] <- base::nrow(combi)/base::nrow(dbMS2)
        
        if (qcdf$nfrag[i] == 1) { qcdf$intoscore[i] <- 1 }
        else {
          qcdf$intoscore[i] <- stats::cor(combi$into_ind.x, combi$into_ind.y, use = "everything", method = "pearson")
        }
      } else {
        qcdf$nfrag[i] <- 0
        qcdf$pfrag[i] <- 0
        qcdf$intoscore[i] <- 0
      }
    }
  }
  
  qcdf$pfrag <- base::round(qcdf$pfrag, digits = 2)
  qcdf$intoscore <- base::round(base::as.numeric(qcdf$intoscore), digits = 4)
  
  #TODO Implement isotope check
  
  QC <- list()
  QC[["df"]] <- dplyr::select(qcdf, -hasMS2, -mzMS2, -intMS2, -preMS2)
  
  if (plot) {
    evalPlot <- gridExtra::arrangeGrob(
      ggplot2::ggplot(qcdf) +
        ggplot2::theme_bw() +
        ggplot2::geom_rect(ggplot2::aes(ymin = -10, ymax = 10, xmin = -Inf, xmax = Inf), fill = "ForestGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = -15, ymax = -10, xmin = -Inf, xmax = Inf), fill = "PaleGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = 10, ymax = 15, xmin = -Inf, xmax = Inf), fill = "PaleGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = -Inf, ymax = -15, xmin = -Inf, xmax = Inf), fill = "white", alpha = 0.01) +
        ggplot2::geom_rect(ggplot2::aes(ymin = 15, ymax = Inf, xmin = -Inf, xmax = Inf), fill = "white", alpha = 0.01) +
        ggplot2::geom_point(stat = "identity",
                            ggplot2::aes(x = name,
                                         y = d_rt)) +
        ggplot2::theme(axis.title.y = ggplot2::element_blank(),
                       axis.text.y = ggplot2::element_text(size = 7),
                       axis.text.x = ggplot2::element_text(size = 7),
                       axis.title.x = ggplot2::element_text(size = 7)) +
        ggplot2::ylab("RT diff (sec)") +
        ggplot2::ylim(-rtWindow,rtWindow) +
        ggplot2::coord_flip(),
      ggplot2::ggplot(qcdf) +
        ggplot2::theme_bw() +
        ggplot2::geom_rect(ggplot2::aes(ymin = -Inf, ymax = 5, xmin = -Inf, xmax = Inf), fill = "ForestGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = 5, ymax = 10, xmin = -Inf, xmax = Inf), fill = "PaleGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = 10, ymax = Inf, xmin = -Inf, xmax = Inf), fill = "white", alpha = 0.01) +
        ggplot2::geom_point(stat = "identity",
                            ggplot2::aes(x = name,
                                         y = d_ppm)) +
        ggplot2::theme(axis.text.y = ggplot2::element_blank(),
                       axis.title.y = ggplot2::element_blank(),
                       axis.text.x = ggplot2::element_text(size = 7),
                       axis.title.x = ggplot2::element_text(size = 7)) +
        ggplot2::ylab("m/z diff (ppm)") +
        ggplot2::ylim(0,ppmWindow) +
        ggplot2::coord_flip(), 
      ggplot2::ggplot(qcdf) +
        ggplot2::theme_bw() +
        ggplot2::geom_rect(ggplot2::aes(ymin = 2, ymax = 5, xmin = -Inf, xmax = Inf), fill = "PaleGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = 5, ymax = Inf, xmin = -Inf, xmax = Inf), fill = "ForestGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = -Inf, ymax = 2, xmin = -Inf, xmax = Inf), fill = "white", alpha = 0.01) +
        ggplot2::geom_point(stat = "identity",
                            ggplot2::aes(x = name,
                                         y = nfrag)) +
        ggplot2::theme(axis.text.y = ggplot2::element_blank(),
                       axis.title.y = ggplot2::element_blank(),
                       axis.text.x = ggplot2::element_text(size = 7),
                       axis.title.x = ggplot2::element_text(size = 7)) +
        ggplot2::ylab("Nr Shared Top10 MS2") +
        #ylim(0,10) +
        ggplot2::scale_y_continuous(limits = c(0, 10), breaks = base::seq(0, 10, by = 2)) +
        ggplot2::coord_flip(),
      ggplot2::ggplot(qcdf) +
        ggplot2::theme_bw() +
        ggplot2::geom_rect(ggplot2::aes(ymin = 0.95, ymax = Inf, xmin = -Inf, xmax = Inf), fill = "ForestGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = 0.9, ymax = 0.95, xmin = -Inf, xmax = Inf), fill = "PaleGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = -Inf, ymax = 0.9, xmin = -Inf, xmax = Inf), fill = "white", alpha = 0.01) +
        ggplot2::geom_point(stat = "identity",
                            ggplot2::aes(x = name,
                                         y = intoscore)) +
        ggplot2::theme(axis.text.y = ggplot2::element_blank(),
                       axis.title.y = ggplot2::element_blank(),
                       axis.text.x = ggplot2::element_text(size = 7),
                       axis.title.x = ggplot2::element_text(size = 7)) +
        ggplot2::ylab("MS2 Intensity Corr.") +
        ggplot2::ylim(0.7,1) +
        ggplot2::coord_flip(),
      ncol = 4, widths = base::c(8,4,4,4))
    
    
    featPlot <- ntsIUTA::plotFeaturePeaks(qcPat, fileIndex = NULL,
                                          features = qcdf$group,
                                          mz = NULL, ppm = NULL,
                                          rt = NULL, rtWindow = NULL,
                                          rtUnit = "min",
                                          plotBy = "features",
                                          names = qcdf$name)
    
    if (save) {
      results <- base::paste0(projPath,"\\results")
      if (!base::dir.exists(results)) base::dir.create(results)
      ggplot2::ggsave(base::paste0(projPath,"/results/QC_Deviations.tiff"),
                      plot = evalPlot, device = "tiff", path = NULL, scale = 1,
                      width = 17, height = 10, units = "cm", dpi = 300, limitsize = TRUE)
      htmlwidgets::saveWidget(plotly::partial_bundle(alignPlot), file = base::paste0(projPath,"/results/QC_Alignment.html"))
      htmlwidgets::saveWidget(plotly::partial_bundle(featPlot), file = base::paste0(projPath,"/results/QC_Features.html"))
    }
    
    QC[["alignPlot"]] <- alignPlot
    QC[["featPlot"]] <- featPlot
    QC[["evalPlot"]] <- evalPlot
    
  }
  
  if (save) {
    results <- base::paste0(projPath,"\\results")
    if (!base::dir.exists(results)) base::dir.create(results)
    utils::write.csv(dplyr::select(qcdf, -hasMS2, -mzMS2, -intMS2, -preMS2), file = base::paste0(projPath,"/results/QC_CheckResults.csv"))
    rData <- base::paste0(projPath,"\\rData")
    if (!base::dir.exists(rData)) base::dir.create(rData)
    base::saveRDS(QC, file = base::paste0(rData,"\\QC.rds"))
  }
  
  return(QC)
  
}




#' @title makeFeatureComponents
#' @description Uses the \pkg{CAMERA} package to find isotopes by grouping features over the retention time
#' and extracted ion chromotogram (EIC) for the given deviations. The isotopes are found for each replicate group.
#'
#' @param featData An \linkS4class{XCMSnExp} object containing features.
#' @param polarity The polarity of the replicate groups. Possible values are \code{positive} or \code{negative}.
#' @param sigma The multiplier of the standard deviation for grouping features by retention time.
#' @param perfwhm Percentage of the width of the FWHM.
#' @param cor_eic_th Minimum correlation index (from 0 to 1) for the EICs of features within the same sample.  
#' @param cor_exp_th Minimum correlation index (from 0 to 1) for the EICs of features across samples within the replicate group.
#' @param pval p-value threshold for testing correlation of significance.
#' @param calcCaS Logical, set to \code{TRUE} to calculate correlation accross samples. Deafault is \code{TRUE}.
#' @param calcIso Logical, set to \code{TRUE} to include isotope detection informationen for graph clustering. Deafault is \code{FALSE}.
#' @param ppmIsotopes The expected mass deviation to find isotopes.
#' @param mzabs The expected deviation of the \emph{m/z} to find isotopes.
#' @param noise The extimated intensity threshold for the noise level used for find isotopes.
#' @param validateIsotopePatterns Logical, set to \code{TRUE} for validating the annoatated isotopes with the kegg database. 
#' @param searchAdducts Logical, set to \code{TRUE} to screen for adducts after finding isotopes.
#' @param ppmAdducts The expected mass deviation to find adducts.
#' @param extendedList Logical, set to \code{TRUE} to use the extended list of adducts. The default (\code{FALSE} uses a shorter list.)
#' @param excludeBlanks Set to \code{TRUE} to not screen blank samples for isotopes and adducts.
#' This option is intended for saving processing time as the replicate blank groupes are expected to be removed before final feature list creation.
#' @param blankGroups A character vector with the name of the blank replicate groups in the given \code{featData} object.
#' For simplification use \code{base::unique(sampleInfo$blank)}.
#' @param save Logical, set to \code{TRUE} to save the generated \code{list} of \linkS4class{xsAnnotate} objects in the disk.
#' @param projPath The \code{projPath} directory as defined in the \code{setup} object.
#'
#' @return A \code{list} with an \linkS4class{xsAnnotate} object per replicate group as defined in the given \linkS4class{XCMSnExp} object.
#' 
#' @references
#' \insertRef{CAMERA}{ntsIUTA}
#' \insertRef{xcms1}{ntsIUTA}
#' \insertRef{xcms2}{ntsIUTA}
#' \insertRef{xcms3}{ntsIUTA}
#' 
#' @export
#' 
#' @importFrom methods as
#' @importFrom xcms filterMsLevel sampnames
#' @importFrom Biobase pData
#' @importFrom CAMERA xsAnnotate groupFWHM groupCorr findAdducts
#' @importFrom utils txtProgressBar setTxtProgressBar read.table
#'
#' @examples
#' 
#' 
#' 
makeFeatureComponents <- function(featData = featData, polarity = "positive",
                                  sigma = 5, perfwhm = 0.5, cor_eic_th = 0.85,
                                  cor_exp_th = 0.75, pval = 0.05,
                                  calcCaS = TRUE, calcIso = TRUE,
                                  ppmIsotopes = 50, mzabs = 0.01, noise = 350,
                                  validateIsotopePatterns = TRUE,
                                  searchAdducts = TRUE, ppmAdducts = 5, extendedList = FALSE,
                                  excludeBlanks = TRUE, blankGroups = "Blank",
                                  save = TRUE, projPath = setup$projPath) {
  
  #Examples
  # setup <- ntsIUTA::makeSetup(projPath = system.file(package = "ntsIUTA", dir = "extdata"), save = FALSE)
  # setup$sampleInfo[1:3,"group"] <- "Sample"
  # rawDataExample <- ntsIUTA::importRawData(setup$sampleInfo[1:3,], save = FALSE, centroidedData = TRUE)
  # peaksDataExample <- ntsIUTA::peakPicking(rawDataExample, param = param, save = FALSE)
  # paramList <- ntsIUTA::paramListExample
  # instParam <- ntsIUTA::getInstParam(paramList)
  # peaksDataExample <- ntsIUTA::peakPicking(rawDataExample, param = instParam$PP, save = FALSE)
  # featDataExample <- ntsIUTA::makeFeatures(peaksDataExample, paramPreGrouping = instParam$preGrouping, paramAlignment = instParam$alignment, paramGrouping = instParam$grouping, save = FALSE)
  # featCompExample <- ntsIUTA::makeFeatureComponents(featData = featDataExample)
  
  
  # featData = featData
  # polarity = "positive"
  # sigma = 5
  # perfwhm = 0.45
  # cor_eic_th = 0.85
  # cor_exp_th = 0.85
  # pval = 0.05
  # ppmIsotopes = 50
  # mzabs = 0.01
  # noise = 350
  # searchAdducts = TRUE
  # ppmAdducts = 5
  # extendedList = FALSE
  # excludeBlanks = FALSE
  # calcCaS = TRUE
  # calcIso = TRUE
  
  #convert featData to xcmsSet class
  xSet <- methods::as(xcms::filterMsLevel(featData,  msLevel. = 1), "xcmsSet")
  xcms::sampnames(xSet) <- Biobase::pData(featData)$sample_name
  xcms::sampclass(xSet) <- Biobase::pData(featData)$sample_group
  #xSet <- xcms::fillPeaks(xSet) #not used as filling was already performed
  
  #Replicate sample group divider
  groups <- base::unique(featData$sample_group)
  
  
  if (excludeBlanks) groups <- groups[groups != blankGroups]
  
  #Holder for isotopes from each replicate group as list() and indices for which replicate group
  featComp <- base::list()
  
  xA <- CAMERA::xsAnnotate(xs = xSet, sample = c(1:base::length(featData$sample_group)),
                           polarity = polarity)
  
  xA <- CAMERA::groupFWHM(xA, sigma = sigma, #the multiplier of the standard deviation
                          perfwhm = perfwhm, #percentage of the width of the FWHM
                          intval = "maxo")
  
  xA <- CAMERA::groupCorr(xA, cor_eic_th = cor_eic_th, # Correlation threshold for EIC correlation
                          pval = pval, # p-value threshold for testing correlation of signiﬁcance
                          graphMethod = "hcs",
                          calcIso = calcIso, calcCiS = TRUE, calcCaS = calcCaS, psg_list = NULL, xraw = NULL,
                          cor_exp_th = cor_exp_th, # Threshold for intensity correlations across samples
                          intval = "maxo") #suppressWarnings()
  
  # test <- CAMERA::getPeaklist(xA)
  # test <- dplyr::filter(test, pcgroup == 8)
  # #testx <- as.data.frame(xcms::featureDefinitions(featData))
  # #testX <-base::row.names(xcms::featureDefinitions(featData))
  
  
  #Make peaksData by replicate groups as defined in the setup experiment
  pb <- utils::txtProgressBar(min = 0, max = 100, initial = 0, char = "=", width = 80, style = 3)
  
  for (rgidx in 1:base::length(groups)) {
    
    utils::setTxtProgressBar(pb, ((rgidx/base::length(groups))*100))
    
    sampleidxs <- base::which(featData$sample_group == groups[rgidx])
    
    xA_temp <- ntsIUTA::FindIsotopesWithValidationAltered(object = xA,
                                                          featData = featData,
                                                          sampleidxs = sampleidxs,
                                                          ppm = ppmIsotopes,
                                                          mzabs = mzabs,
                                                          noise = noise,
                                                          maxcharge = 3, #maxcharge set to match small molecules and lipids
                                                          intval = "maxo",
                                                          validateIsotopePatterns = validateIsotopePatterns)
    
    if (searchAdducts)
    {
      if (extendedList) {
        rules_pos <- base::system.file('rules/extended_adducts_pos.csv', package = "CAMERA")
        rules_neg <- base::system.file('rules/extended_adducts_neg.csv', package = "CAMERA")
      } else {
        rules_pos <- base::system.file('rules/primary_adducts_pos.csv', package = "CAMERA")
        rules_neg <- base::system.file('rules/primary_adducts_neg.csv', package = "CAMERA")
      }
      
      
      if (polarity == "positive")
      {rules <- utils::read.table(rules_pos, header = TRUE, sep = ",")}
      
      if (polarity == "negative")
      {rules <- utils::read.table(rules_neg, header = TRUE, sep = ",")}
      
      
      xA_temp <- CAMERA::findAdducts(xA_temp,
                                     ppm = ppmAdducts,
                                     mzabs = 0,
                                     multiplier = 2, # highest number(n) of allowed clusterion [nM+ion]
                                     polarity = polarity,
                                     rules = rules,
                                     max_peaks = 100, # If run in parralel mode, this number deﬁnes how much peaks will be calculated in every thread
                                     psg_list = NULL) # Vector of pseudospectra indices. The correlation analysis will be only done for those groups
    }
    
    featComp[[groups[rgidx]]] <- xA_temp
    
  }
  
  if (save)
  {
    rData <- base::paste0(projPath,"\\rData")
    if (!base::dir.exists(rData)) base::dir.create(rData)
    base::saveRDS(featComp, file = base::paste0(rData,"\\featComp.rds"))
  }
  
  return(featComp)
  
}




#' @title plotComponentSpectrum
#' @description Plots the spectra for given features, \emph{m/z} and rt or components from a list of \linkS4class{xsAnnotate} objects.
#' 
#' 
#' @param xA The list of \linkS4class{xsAnnotate} objects obtained via \code{\link{makeFeatureComponents}}.
#' @param replicateGroups The replicate groups name or number to filter the \code{xA} list,
#' which is named according to the experimental replicate groups as defined in \code{\link{setupProject}}.
#' @param features Feature identifier/s.
#' @param featData The feature data to get the feature identifiers.
#' Can be a \linkS4class{XCMSnExp} or \linkS4class{featureGroups} object from \pkg{xcms} or \pkg{patRoon}, respectively.
#' @param mz The \emph{m/z} of interest. If \code{features} are specified \code{mz is not used}.
#' @param ppm The expected mass deviation to search for features of a given \code{mz}.
#' @param mzWindowPlot The \emph{m/z} range for the plot.
#' @param rt The expected retention time of the \emph{m/z} of interest, only used if \code{features} are not speficied.
#' @param rtWindow The expected retention time deviation for searching.
#' @param rtUnit The time unit used. Default is minutes.
#' @param comp The component numbers to plot. Only used if both \code{features} and \code{mz} are \code{NULL} (i.e. not specified).
#' @param onlyAnnotated Plots only annotated features.
#' @param onlyRelated Plots only relevant features (i.e. isotopes and addcuts) of the specified features. 
#' @param intval The intensity value type. Default is "maxo", corresponding to the height.
#' @param log Logical, set to \code{TRUE} (the default) to plot the intensities in a log scale.
#'
#' @return A spectrum plot of given components or features.
#' 
#' @export
#' 
#' @importFrom patRoon as.data.table
#' @importFrom xcms featureSummary featureDefinitions
#' @importFrom CAMERA getPeaklist
#' @importFrom dplyr select everything between filter all_of
#' @importFrom stringr str_extract
#' @importFrom plotly plot_ly add_bars toRGB layout
#'
#' @examples
#' 
#' 
#' 
plotComponentSpectrum <- function(xA = featComp, replicateGroups = NULL,
                                  features = NULL, featData = featData,
                                  mz = NULL, ppm = 5, mzWindowPlot = NULL,
                                  rt = NULL, rtWindow = 1, rtUnit = "min",
                                  comp = NULL,
                                  onlyAnnotated = FALSE, onlyRelated = TRUE,
                                  intval = "maxo",
                                  log = TRUE) {
  
  # featData = featData
  # xA = featComp
  # replicateGroups = 2
  # features = NULL #"FT0107"
  # comp = NULL
  # onlyAnnotated = FALSE
  # onlyRelated = TRUE
  # mz = 233.0249
  # ppm = 5
  # rt = 15.7
  # rtWindow = 1
  # mzWindowPlot = c(200,300)
  # rtUnit = "min"
  # intval = "maxo"
  # log = TRUE
  
  
  #library(magrittr)
  
  #filter for a replicate group or for all
  fileIndex <- 1:base::length(xA[[1]]@xcmsSet$sample_group)
  rGroups <- base::names(xA)
  rIndex <- 1:base::length(xA)
  if (!is.null(replicateGroups)){
    if (is.character(replicateGroups)) {
      fileIndex <- base::which(xA[[1]]@xcmsSet$sample_group %in% rGroups[rGroups == replicateGroups])
      sampleNames <-  xA[[1]]@xcmsSet$sample_name[xA[[1]]@xcmsSet$sample_group %in% rGroups[rGroups == replicateGroups]]
      groupNames <- xA[[1]]@xcmsSet$sample_group[xA[[1]]@xcmsSet$sample_group %in% rGroups[rGroups == replicateGroups]]
      rIndex <- base::which(rGroups %in% replicateGroups)
    } else {
      fileIndex <- base::which(xA[[1]]@xcmsSet$sample_group %in% rGroups[replicateGroups])
      sampleNames <-  xA[[1]]@xcmsSet$sample_name[xA[[1]]@xcmsSet$sample_group %in% rGroups[replicateGroups]]
      groupNames <- xA[[1]]@xcmsSet$sample_group[xA[[1]]@xcmsSet$sample_group %in% rGroups[replicateGroups]]
      rIndex <- replicateGroups
    }
  }
  
  #When feature ID is given to look for spectra
  FT <- NULL
  if (!base::is.null(features))
  {
    if (base::unique(base::grepl("M*_R", features, fixed = FALSE))) {
      x <- featData
      featData <- featData@xdata
      gKey <- base::cbind(patRoon::as.data.table(x, average = TRUE)[,.SD, .SDcols = "group"],
                          base::data.frame(FT = base::row.names(xcms::featureSummary(featData))))
      gKey <- base::as.data.frame(gKey)
      FT <- gKey[gKey$group %in% features, "FT", drop = T]
    } else {
      FT <- features
    }
    for (r in rIndex) {
      ft_temp <- dplyr::select(base::as.data.frame(xcms::featureDefinitions(featData)), "mzmed")
      ft_temp$FT <- base::row.names(ft_temp)
      ft_temp$rGroup <- rGroups[r]
      ano_temp <- CAMERA::getPeaklist(xA[[r]], intval = intval)
      ano_temp <- base::cbind(ft_temp[,c("rGroup","FT"), drop=F],ano_temp)
      if (r == 1) {
        ano <- ano_temp
      } else {
        ano <- base::rbind(ano,ano_temp)
      }
    }
    #get comp of features
    pcgroups <- as.numeric(ano[ano$FT %in% FT,"pcgroup", drop = T])
    
  } else {
    #When features are not given but a specific mz +/- ppm  
    if (!is.null(mz)) {
      
      if (!base::is.null(rt)) if (rtUnit == "min") rt <- rt*60
      if (!base::is.null(rtWindow)) if (rtUnit == "min") rtWindow <- rtWindow*60
      if (!base::is.null(rt) & !base::is.null(rtWindow) & (base::length(rtWindow) == 1)) { rtr <- c(rt-rtWindow, rt+rtWindow) }
      if (base::is.null(rt)) if (!base::is.null(rtWindow)) if (base::length(rtWindow) == 2) { rtr <- rtWindow }
      if (!base::is.null(rt) & base::is.null(rtWindow)) {rtr <- c(rt-10, rt+10)}
      
      if (length(mz) == 1) { mzr <- c(mz - ((ppm/1E6)*mz), mz + ((ppm/1E6)*mz)) }
      if (length(mz) == 2) { mzr <- c(mz[1], mz[2]) }
      
      for (r in rIndex) {
        ano_temp <- CAMERA::getPeaklist(xA[[r]], intval = intval)
        ano_temp$rGroup <- rGroups[r]
        ano_temp <- dplyr::select(ano_temp, rGroup, dplyr::everything())
        if (r == 1 | length(rIndex) == 1) {
          ano <- ano_temp
        } else {
          ano <- base::rbind(ano,ano_temp)
        }
      }
      
      pcgroups <- ano %>% dplyr::filter(dplyr::between(rt, rtr[1],rtr[2]))
      pcgroups <- pcgroups %>% dplyr::filter(dplyr::between(mz, mzr[1],mzr[2]))
      pcgroups <- as.numeric(pcgroups$pcgroup[drop=F])
      
    } else {
      
      #When only the comp number is given
      if (base::is.null(comp)) stop("At least one of the three, Feature ID, m/z and RT range or component number (comp) should be given.")
      
      for (r in rIndex) {
        ano_temp <- CAMERA::getPeaklist(xA[[r]], intval = intval)
        ano_temp$rGroup <- rGroups[r]
        ano_temp <- dplyr::select(ano_temp, rGroup, dplyr::everything())
        if (r == 1) {
          ano <- ano_temp
        } else {
          ano <- base::rbind(ano,ano_temp)
        }
      }
      
      pcgroups <- as.numeric(comp)
      
    }
  }
  
  #filter by relevent pcgroups
  ano <- ano[ano$pcgroup %in% pcgroups,]
  
  #filter by showing only related features (i.e. isotopes and adducts)
  if (onlyRelated) {
    #when features are given
    if (!base::is.null(FT)) {
      temp_FT <- ano[ano$FT %in% FT,, drop = F]
      iso_group <- base::gsub("\\D", "", temp_FT$isotopes[drop = T])
      iso_group <- iso_group[iso_group != ""]
      adduct_Mion <- stringr::str_extract(temp_FT$adduct[drop = T], "[0-9]+\\.[0-9]+")
      adduct_Mion <- adduct_Mion[!is.na(adduct_Mion)]
      adduct_temp <- ano[base::grepl(paste(adduct_Mion, collapse = "|"), ano$adduct[drop = T]),]
      iso_adduct <- base::gsub("\\D", "", adduct_temp$isotopes[drop = T])
      iso_adduct <- iso_adduct[iso_adduct != ""]
      iso_group <- base::unique(c(iso_group,iso_adduct))
      #leave only iso_group features
      rel_temp <- ano[base::grepl(base::paste(iso_group, collapse = "|"), ano$isotopes[drop = T])|
                        base::grepl(base::paste(adduct_Mion, collapse = "|"), ano$adduct[drop = T]),]
    } else {
      if (!is.null(mz)) {
        temp_FT <- ano %>% dplyr::filter(dplyr::between(rt, rtr[1],rtr[2]))
        temp_FT <- temp_FT %>% dplyr::filter(dplyr::between(mz, mzr[1],mzr[2]))
        iso_group <- base::gsub("\\D", "", temp_FT$isotopes[drop = T])
        iso_group <- iso_group[iso_group != ""]
        adduct_Mion <- stringr::str_extract(temp_FT$adduct[drop = T], "[0-9]+\\.[0-9]+")
        adduct_Mion <- adduct_Mion[!is.na(adduct_Mion)]
        adduct_temp <- ano[base::grepl(paste(adduct_Mion, collapse = "|"), ano$adduct[drop = T]),]
        iso_adduct <- base::gsub("\\D", "", adduct_temp$isotopes[drop = T])
        iso_adduct <- iso_adduct[iso_adduct != ""]
        iso_group <- base::unique(c(iso_group,iso_adduct))
        #leave only iso_group features
        rel_temp <- ano[base::grepl(base::paste(iso_group, collapse = "|"), ano$isotopes[drop = T])|
                          base::grepl(base::paste(adduct_Mion, collapse = "|"), ano$adduct[drop = T]),]
      }
    }
    
    if(base::exists("rel_temp")) {ano <- ano[ano$mz %in% rel_temp$mz,]}
  }
  
  #filter ano by selecting only annotated Features
  if (onlyAnnotated) {
    ano <- dplyr::filter(ano, isotopes != "" | ano$adduct != "")  
  }
  
  #add text for labels to ano
  ano$text <- paste0(round(ano$mz, digits = 2),ano$isotopes, ano$adduct)
  
  #check the col names for duplicates
  sampleNamesRepeats <- ifelse(xA[[1]]@xcmsSet$sample_name %in% xA[[1]]@xcmsSet$sample_group,
                               paste0(xA[[1]]@xcmsSet$sample_name,".1"),xA[[1]]@xcmsSet$sample_name)
  
  #calculate averages for the intensites
  anoS <- dplyr::select(ano, -all_of(xA[[1]]@xcmsSet$sample_name), -all_of(xA[[1]]@xcmsSet$sample_group), -all_of(sampleNamesRepeats))
  
  for (r in rIndex) {
    anoS[,rGroups[r]] <- apply(ano[,colnames(ano) %in% sampleNamesRepeats[xA[[1]]@xcmsSet$sample_group %in% rGroups[r]], drop = F],
                               MARGIN = 1, FUN = function(x) base::ifelse(log, base::log(base::mean(x)), base::mean(x))) 
  }
  
  if (!base::is.null(mzWindowPlot)) {
    if (base::length(mzWindowPlot) == 2) mzrange <- mzWindowPlot
  } else {
    mzrange <- c(base::min(anoS$mz)*0.9, base::max(anoS$mz)*1.1)
  }
  intrange <- c(0, base::max(anoS[,colnames(anoS) %in% rGroups], na.rm = TRUE)*2) 
  
  colors <- ntsIUTA::getColors(base::length(rGroups))
  
  fig <- plotly::plot_ly(anoS, type = "bar")
  
  for (s in rIndex) { 
    
    fig <- fig %>% plotly::add_bars(x = anoS$mz[anoS$rGroup %in% rGroups[s]],
                                    y = anoS[anoS$rGroup %in% rGroups[s],colnames(anoS) %in% rGroups[s], drop = T],
                                    marker = list(color = colors[s]),  width = 0.05,
                                    text = anoS$text[anoS$rGroup %in% rGroups[s]],
                                    textposition = 'outside', textangle = -90, insidetextanchor = "middle",
                                    textfont = list(size = 10, color = colors[s]),
                                    name = rGroups[s])
  }
  
  #title <- base::list(text = "Coisas", x = 0.1, y = 0.98, font = base::list(size = 14, color = "black"))
  
  xaxis <- base::list(linecolor = plotly::toRGB("black"), linewidth = 2, title = "m/z",
                      titlefont = base::list(size = 12, color = "black"),
                      range = mzrange)
  
  yaxis = list(linecolor = plotly::toRGB("black"), linewidth = 2, title = base::ifelse(log, "log(Intensity)", "Intensity"),
               titlefont = list(size = 12, color = "black"), range = intrange) #, range = intrange
  
  fig <- fig %>% plotly::layout(xaxis = xaxis, yaxis = yaxis, barmode = "overlay", uniformtext = list(minsize = 4, mode = "show"))
  
  return(fig)
  
}




#' @title plotFeaturesOld
#' @description Plot features from a \linkS4class{featureGroups}.
#'
#' @param features A \linkS4class{featureGroups} object with one or more files and grouped peaks (i.e., features).
#' @param fileIndex The index of the file/s to extract the centroids or profile data.
#' @param ID The identifier of the features of interest. When not \code{NULL}, overwrites any given \code{mz} and \code{rt} value.
#' @param mz Optional target \emph{m/z} to find features using the mass deviation specified by the \code{ppm} parameter.
#' @param ppm The mass deviation to extract the features when \code{mz} is specified.
#' @param rt The retention time in minutes or seconds, depending on the defined \code{rtUnit}, see below. Only used when \code{mz} is specified.
#' @param rtWindow The time deviation to collect features. The time unit is the defined by \code{rtUnit}.
#' A time interval can be given with a length 2 vector, defining the minimum and maximum retention time.
#' @param rtUnit Possible entries are \code{min} or \code{sec}. The default is \code{min}.
#' @param title The title for the plot, optional.
#' @param plotBy The grouping for the plot. Possible are "samples", "replicates" and "features"
#' for plotting by individual samples, replicate samples or features, respectively. The default is "features".
#'
#' @return A plot produced through pkg{gglpot2}.
#'
#' @note If \code{ID} and \code{mz} are \code{NULL} all the features in the \linkS4class{featureGroups} object are plotted.
#'
#' @export
#'
#' @importClassesFrom patRoon featureGroups
#' @importClassesFrom xcms XCMSnExp
#' @importMethodsFrom patRoon algorithm analyses
#' @importMethodsFrom xcms featureDefinitions chromPeaks
#' @importFrom xcms featureChromatograms
#' @importFrom BiocGenerics as.data.frame
#' @importFrom plotly toRGB plot_ly add_trace layout
#'
#' @examples
#'
plotFeaturesOld <- function(features = features,
                            fileIndex = NULL,
                            ID = NULL,
                            mz = NULL, ppm = 5,
                            rt = NULL, rtWindow = 1,
                            rtUnit = "min",
                            title = NULL, plotBy = "features") {
  
  fileIndex <- NULL
  ID <- NULL #"M748_R891_1274"
  mz <- 748.4842
  rt <- 14.9
  rtUnit <- "min"
  ppm <- NULL
  rtWindow <- NULL
  plotBy <- "features"
  title <- NULL
  
  x <- featuresOpenms
  
  if (!is.null(fileIndex)) x <- x[fileIndex, ]
  
  if (!is.null(ID)) {
    x <- x[, ID]
  } else {
    if (!is.null(mz)) {
      mzr <- mzrBuilder(mz = mz, ppm = ppm)
      rtr <- rtrBuilder(rt = rt, rtWindow = rtWindow, rtUnit = rtUnit)
      x <- patRoon::filter(obj = x, retentionRange = rtr, mzRange = mzr)
    }
  }
  
  ft <- names(x)
  
  sInfo <- analyses(x)
  
  pks <- patRoon::as.data.frame(x,
                                average = FALSE,
                                areas = FALSE,
                                features = TRUE,
                                regression = FALSE
  )
  
  EICs <- list()
  
  for (i in seq_len(nrow(pks))) {
    flidx <- which(sInfo == pks$analysis[i])
    EICs[[rownames(pks)[i]]] <- extractEIC(x, fileIndex = flidx,
                                           mz = c(pks$mzmin[i], pks$mzmax[i]),
                                           rtWindow = c(pks$retmin[i], pks$retmax[i]),
                                           rtUnit = "sec")
  }
  
  
  
  
  
  
  if (algorithm(x) == "openms") {
    x <- getXCMSnExp(x)
    y <- temp
    sn <- matrix(rep(0, nrow(chromPeaks(y))), ncol = 1)
    colnames(sn) <- "sn"
    chromPeaks(y) <- cbind(chromPeaks(y), sn)
    featureDefinitions(y) <- featureDefinitions(temp)
  }
  
  
  
  def <- xcms::featureDefinitions(y, type = "within", msLevel = 1)
  
  chrom <- xcms::featureChromatograms(y, aggregationFun = "sum", expandRt = 60, include = "feature_only", filled = TRUE, missing = 0)
  
  head(xcms::chromPeaks(y, isFilledColumn = TRUE))$sn <- 0
  
  sn <- matrix(rep(0, nrow(xcms::chromPeaks(y))), ncol = 1)
  colnames(sn) <- "sn"
  
  head(sn)
  
  xcms::chromPeaks(y) <- cbind(xcms::chromPeaks(y), sn)
  
  xcms::featureDefinitions(y) <- xcms::featureDefinitions(x@xdata)
  
  
  
  features <- base::character()
  for (f in 1:base::length(FT)) {
    features <- c(features, paste("M", base::round(defFT$mzmed[base::row.names(defFT) %in% FT[f],drop = T], digits = 0),
                                  "_R", base::round(defFT$rtmed[base::row.names(defFT) %in% FT[f],drop = T], digits = 0),
                                  "_", FT[f],sep=""))
  }
  
  # temp_rtFT <- as.data.frame(xcms::chromPeaks(y)[base::unlist(defFT[base::row.names(defFT) %in% FT[f] ,"peakidx"]), ])
  # chrom <- MSnbase::chromatogram(y, aggregationFun = "sum", rt = rtr, msLevel = 1, missing = 0,
  #                                mz = c(base::min(temp_rtFT$mzmin-(ppm/1E6*temp_rtFT$mzmin), na.rm = T),
  #                                       base::max(temp_rtFT$mzmax+(ppm/1E6*temp_rtFT$mzmax), na.rm = T)))
  chrom <- xcms::featureChromatograms(y, features = FT, aggregationFun = "sum", expandRt = 60, include = "any", filled = TRUE, missing = 0)
  
  df <- base::data.frame(rtime = base::as.numeric(), intensity = base::as.numeric(), sample = base::as.character(), FT = base::as.character())
  for (f in 1:base::nrow(def)) {
    for (s in 1:base::ncol(chrom)) {
      temp <- chrom[f, s]
      temp <- BiocGenerics::as.data.frame(temp)
      temp$sample <- y$sample_name[s]
      temp$ft <- ft[f]
      df <- base::rbind(df,temp)
    }
  }
  
  #colors <- ntsIUTA::getColors(y, "samples")
  
  if (base::is.null(title)) title <- if (plotBy == "features") base::ifelse(base::length(FT) == 1, features, "")
  
  title <- base::list(text = title, x = 0.1, y = 0.98, font = base::list(size = 14, color = "black"))
  
  xaxis <- base::list(linecolor = plotly::toRGB("black"), linewidth = 2, title = "Retention Time (sec.)",
                      titlefont = base::list(size = 12, color = "black"),
                      range = c(rtr[1], rtr[2]), autotick = T, ticks = "outside")
  
  yaxis = base::list(linecolor = plotly::toRGB("black"), linewidth = 2, title = "Intensity",
                     titlefont = list(size = 12, color = "black"))
  
  
  if (plotBy == "samples") {
    colors <- ntsIUTA::getColors(y, "samples")
    legG <- y$sample_name
  } else {
    if (plotBy == "features") {
      colors <- ntsIUTA::getColors(base::length(features))
      legG <- features
    } else {
      colors = ntsIUTA::getColors(y, "groups")
      legG <- y$sample_name
    }
  }
  
  
  # if (plotBy == "replicates") legG <- y$sample_group
  # if (plotBy == "samples") legG <- y$sample_name
  
  #By feature the eic followed by the integrated are, legend grouped as function input plotBy
  plot <- plotly::plot_ly(df)
  showlegend = base::rep(0,base::length(features))
  for (s in 1:base::ncol(chrom)) { #base::ncol(feat)
    for (f in 1:base::length(FT)) { #base::nrow(feat)
      showlegend[f] = 1 + showlegend[f]
      plot <- plot %>% plotly::add_trace(df,
                                         x = df[df$FT == FT[f] & df$sample ==  y$sample_name[s], "rtime"],
                                         y = df[df$FT == FT[f] & df$sample ==  y$sample_name[s], "intensity"],
                                         type = "scatter", mode = "lines",
                                         line = base::list(width = 0.5, color = base::unname(colors[base::ifelse(plotBy == "features", f, s)])),
                                         connectgaps = TRUE,
                                         name = legG[base::ifelse(plotBy == "features", f, s)],
                                         legendgroup = legG[base::ifelse(plotBy == "features", f, s)],
                                         showlegend = base::ifelse(plotBy == "samples", base::ifelse(f == 1, T, F),
                                                                   base::ifelse(plotBy == "features", base::ifelse(showlegend[f] == 1, T, F),
                                                                                base::ifelse(f == 1, T, F))))
      
      rtFT <- base::as.data.frame(xcms::chromPeaks(y)[base::unlist(defFT[base::row.names(defFT) %in% FT[f] ,"peakidx"]), ])
      if(unique(TRUE %in% (rtFT$sample == s))) {
        rtFT <- rtFT[rtFT$sample == s, c("rtmin","rtmax")]
        plot <- plot %>%  plotly::add_trace(df,
                                            x = df[df$FT == FT[f] & df$sample ==  y$sample_name[s] & df$rtime >= rtFT[1,1] & df$rtime <= rtFT[1,2], "rtime"],
                                            y = df[df$FT == FT[f] & df$sample ==  y$sample_name[s] & df$rtime >= rtFT[1,1] & df$rtime <= rtFT[1,2],"intensity"],
                                            type = "scatter", mode =  "lines+markers", fill = 'tozeroy', connectgaps = TRUE,
                                            fillcolor = base::paste(color = base::unname(colors[base::ifelse(plotBy == "features", f, s)]),50, sep = ""),
                                            line = base::list(width = 0.1, color = base::unname(colors[base::ifelse(plotBy == "features", f, s)])),
                                            marker = base::list(size = 3, color = base::unname(colors[base::ifelse(plotBy == "features", f, s)])),
                                            name = legG[base::ifelse(plotBy == "features", f, s)],
                                            legendgroup = legG[base::ifelse(plotBy == "features", f, s)],
                                            showlegend = F,
                                            hoverinfo = 'text', text = base::paste('</br> feature: ', features[f],
                                                                                   '</br> sample: ', y$sample_name[s]))
      }
    }
  }
  # showlegend = 0
  # for (s in 1:base::ncol(chrom)) { #base::ncol(feat)
  #   for (f in 1:base::nrow(chrom)) { #base::nrow(feat)
  #     rtFT <- base::as.data.frame(xcms::chromPeaks(y)[base::unlist(defFT[base::row.names(defFT) %in% FT[f] ,"peakidx"]), ])
  #     if(base::unique(TRUE %in% (rtFT$sample == s))) {
  #       showlegend <- 1 + showlegend
  #       rtFT <- rtFT[rtFT$sample == s, c("rtmin","rtmax")]
  #       plot <- plot %>%  plotly::add_trace(df,
  #                                           x = df[df$FT == FT[f] & df$sample ==  y$sample_name[s] & df$rtime >= rtFT[1,1] & df$rtime <= rtFT[1,2], "rtime"],
  #                                           y = df[df$FT == FT[f] & df$sample ==  y$sample_name[s] & df$rtime >= rtFT[1,1] & df$rtime <= rtFT[1,2],"intensity"],
  #                                           type = "scatter", mode = "lines+markers", fill = 'tozeroy', connectgaps = TRUE, fillcolor = paste(color = base::unname(colors[s]),50, sep = ""),
  #                                           line = base::list(width = 0.1, color = base::unname(colors[s])),
  #                                           marker = base::list(size = 3, color = base::unname(colors[s])),
  #                                           name = features[f], legendgroup = FT[f], showlegend = base::ifelse(showlegend == 1, T, F))
  #     }
  #   }
  # }
  
  plot <- plot %>% plotly::layout(xaxis = xaxis,yaxis = yaxis, title = title) #legend = list(title = list(text='<b> Sample: </b>'))
  
  return(plot)
  
}




#' @title plotlyRawChrom
#' @description Plots total, base and extracted ion chromatograms
#' (TIC, BPC and EIC, respectively) of an \linkS4class{ntsData} object,
#' using the \pkg{plotly} package to produce an iterative plot.
#'
#' @param obj An \linkS4class{ntsData} object with one or more files.
#' @param fileIndex The index of the file/s to extract the data.
#' @param mz Optional target \emph{m/z} to obtain an EIC.
#' Note that when not \code{NULL} (the default), EIC is always returned.
#' @param ppm The mass deviation to extract the data for the EIC, in \code{ppm}.
#' @param rt The retention time in minutes or seconds,
#' depending on the defined \code{rtUnit}, see below.
#' @param rtWindow The time window or deviation to collect the data.
#' The time unit is defined by \code{rtUnit}.
#' A time interval can be given with a length 2 vector,
#' defining the minimum and maximum retention time.
#' A vector of length 1 is assumed as a deviation of a given \code{rt}.
#' @param rtUnit Possible entries are \code{sec} (the default) or \code{min}.
#' @param msLevel The MS level to extract the data.
#' For the moment, only 1 is possible.
#' @param type The type of chromatogram.
#' Possible entries are "bpc" for base peak chromatogram
#' or "tic" for total ion chromatogram.
#' The default is "tic". If \code{mz} is specified (not \code{NULL}),
#' the type is set automatically to EIC.
#' @param colorBy Possible values are \code{"samples"} or \code{samplegroups}
#' (the default), for colouring by samples or sample replicate groups respectively.
#'
#' @return An iterative plot for inspection of the raw data
#' in the given \linkS4class{ntsData} object.
#'
#' @export
#'
#' @importMethodsFrom MSnbase filterFile
#' @importFrom plotly toRGB plot_ly add_trace layout
#' @importFrom dplyr group_by arrange top_n summarize
#'
#' @examples
#'
plotlyRawChrom <- function(obj = NULL, fileIndex = NULL,
                           mz = NULL, ppm = 20,
                           rt = NULL, rtWindow = NULL,
                           rtUnit = "sec",
                           msLevel = 1,
                           type = "tic",
                           colorBy = "samplegroups") {
  
  # raw = rawdata
  # fileIndex = NULL
  # mz <- c(233.0243)
  # rt <- NULL
  # rtUnit = "min"
  # ppm <- 20
  # rtWindow = NULL
  # msLevel = 1
  
  if (!is.null(mz) && length(mz) == 1) {
    if (!is.null(ppm)) ppm <- 20
    main <- paste0("EIC of ", round(mz, digits = 4), " +/- ", round(ppm, digits = 0), " ppm")
    type <- "eic"
  } else {
    if (!is.null(mz) && length(mz) == 2) {
      main <- paste0("EIC for ", round(mz[1], digits = 4), "to ", round(mz[2], digits = 4))
      type <- "eic"
    } else {
      main <- toupper(type)
    }
  }
  
  if (!is.null(fileIndex)) obj <- obj[fileIndex]
  
  df <- extractEIC(obj = obj,
                   fileIndex = NULL,
                   mz = mz, ppm = ppm,
                   rt = rt, rtWindow = rtWindow,
                   rtUnit = rtUnit, msLevel = 1,
                   normIntensity = FALSE)
  
  if (type == "tic") {
    mz <- df %>% group_by(rt) %>% top_n(1, i)
    mz <- as.data.frame(mz)
    mz <- arrange(mz, rt)
    y <- df %>% group_by(rt) %>% summarize(i = sum(i))
    y <- as.data.frame(y)
    y <- arrange(y, rt)
    mz$i <- y[, "i", drop = TRUE]
    df <- mz
  }
  
  if (type == "bpc") {
    y <- df %>% group_by(rt) %>% top_n(1, i)
    y <- as.data.frame(y)
    df <- arrange(y, rt)
  }
  
  for (i in seq_len(length(unique(df$file)))) {
    df[df$file == i, "file"] <- samples(obj)[i]
  }
  
  cl <- getColors(obj, which = colorBy)
  
  title <- list(text = main, x = 0.1, y = 0.98, font = list(size = 14, color = "black"))
  
  xaxis <- list(linecolor = toRGB("black"),
                linewidth = 2, title = "Retention Time (sec.)",
                titlefont = list(size = 12, color = "black"))
  
  yaxis <- list(linecolor = toRGB("black"),
                linewidth = 2, title = "Intensity",
                titlefont = list(size = 12, color = "black"))
  
  plot <- plot_ly(df,
                  x = df[df$file == samples(obj)[1], "rt"],
                  y = df[df$file == samples(obj)[1], "i"],
                  type = "scatter", mode = "lines+markers",
                  line = list(width = 0.5, color = unname(cl[1])),
                  marker = list(size = 2, color = unname(cl[1])),
                  name = samples(obj)[1])
  
  if (length(unique(df$file)) > 1) {
    for (i in 2:length(unique(df$file))) {
      plot  <- plot %>% add_trace(df,
                                  x = df[df$file == samples(obj)[i], "rt"],
                                  y = df[df$file == samples(obj)[i], "i"],
                                  type = "scatter", mode = "lines+markers",
                                  line = list(width = 0.5, color = unname(cl[i])),
                                  marker = list(size = 2, color = unname(cl[i])),
                                  name = samples(obj)[i])
    }
  }
  
  plot <- plot %>% layout(legend = list(title = list(text = "<b> Sample: </b>")),
                          xaxis = xaxis, yaxis = yaxis, title = title)
  
  return(plot)
  
}



#' @title plotRawChromOld
#' @description Plots total, base and extracted ion chromatograms
#' (TIC, BPC and EIC, respectively) of an \linkS4class{ntsData} object.
#'
#' @param obj An \linkS4class{ntsData} object with one or more files.
#' @param fileIndex The index of the file/s to extract the data.
#' @param mz Optional target \emph{m/z} to obtain an EIC.
#' Note that when not \code{NULL} (the default), EIC is always returned.
#' @param ppm The mass deviation to extract the data for the EIC, in \code{ppm}.
#' @param rt The retention time in minutes or seconds,
#' depending on the defined \code{rtUnit}, see below.
#' @param rtWindow The time window or deviation to collect the data.
#' The time unit is defined by \code{rtUnit}.
#' A time interval can be given with a length 2 vector,
#' defining the minimum and maximum retention time.
#' A vector of length 1 is assumed as a deviation of a given \code{rt}.
#' @param rtUnit Possible entries are \code{sec} (the default) or \code{min}.
#' @param msLevel The MS level to extract the data.
#' For the moment, only 1 is possible.
#' @param type The type of chromatogram.
#' Possible entries are "bpc" for base peak chromatogram
#' or "tic" for total ion chromatogram.
#' The default is "tic". If \code{mz} is specified (not \code{NULL}),
#' the type is set automatically to EIC.
#' @param colorBy Possible values are \code{"samples"} or \code{samplegroups}
#' (the default), for colouring by samples or sample replicate groups respectively.
#'
#' @return A plot for inspection of the raw data
#' in the given \linkS4class{ntsData} object.
#'
#' @export
#'
#' @importMethodsFrom ProtGenerics rtime
#' @importMethodsFrom MSnbase filterFile rtime
#' @importFrom plotly toRGB plot_ly add_trace layout
#' @importFrom dplyr group_by arrange top_n summarize
#'
#' @examples
#'
plotRawChromOld <- function(obj = NULL, fileIndex = NULL,
                          mz = NULL, ppm = 20,
                          rt = NULL, rtWindow = NULL,
                          rtUnit = "sec",
                          msLevel = 1,
                          type = "tic",
                          colorBy = "samplegroups") {
  
  # raw = rawdata
  # fileIndex = NULL
  # mz <- c(233.0243)
  # rt <- NULL
  # rtUnit = "min"
  # ppm <- 20
  # rtWindow = NULL
  # msLevel = 1
  
  if (!is.null(mz) && length(mz) == 1) {
    if (!is.null(ppm)) ppm <- 20
    main <- paste0("EIC of ", round(mz, digits = 4), " +/- ", round(ppm, digits = 0), " ppm")
    type <- "eic"
  } else {
    if (!is.null(mz) && length(mz) == 2) {
      main <- paste0("EIC for ", round(mz[1], digits = 4), "to ", round(mz[2], digits = 4))
      type <- "eic"
    } else {
      main <- toupper(type)
    }
  }
  
  if (!is.null(fileIndex)) obj <- obj[fileIndex]
  
  df <- extractEIC(obj = obj,
                   fileIndex = NULL,
                   mz = mz, ppm = ppm,
                   rt = rt, rtWindow = rtWindow,
                   rtUnit = rtUnit, msLevel = 1,
                   normIntensity = FALSE)
  
  if (type == "tic") {
    mz <- df %>% group_by(rt) %>% top_n(1, i)
    mz <- as.data.frame(mz)
    mz <- arrange(mz, rt)
    y <- df %>% group_by(rt) %>% summarize(i = sum(i))
    y <- as.data.frame(y)
    y <- arrange(y, rt)
    mz$i <- y[, "i", drop = TRUE]
    df <- mz
  }
  
  if (type == "bpc") {
    y <- df %>% group_by(rt) %>% top_n(1, i)
    y <- as.data.frame(y)
    df <- arrange(y, rt)
  }
  
  for (i in seq_len(length(unique(df$file)))) {
    df[df$file == i, "file"] <- samples(obj)[i]
  }
  
  cl <- getColors(obj, which = colorBy)
  
  plot <- ggplot(data = df, aes(x = rt, y = i, color = file)) +
    geom_line(size = 0.5) +
    scale_color_manual(values = cl) +
    ggtitle(main) +
    theme_bw() +
    ylab("Intensity") +
    xlab("Retention Time") +
    theme(legend.title = element_blank())
  
  return(plot)
  
}



#' @param ppmForFillingGroups The mass (in ppm) to expand the \emph{mz} for filling missing peaks in incomplete features.
#' See \code{\link[xcms]{fillChromPeaks}} for more information.

#Fill missing peaks in feature groups
  #Old parameter used: FillChromPeaksParam(ppm = ppmForFillingGroups)
  featData <- base::suppressWarnings(xcms::fillChromPeaks(featData, param = xcms::ChromPeakAreaParam(),
                                                          BPPARAM = BiocParallel::bpparam("SnowParam")))
  
  # add optinally to apply correction of retention time, avoiding another function from xcms
  # if (length(peaksDataUnified$sample_name) > 1) {
  #   featData <- xcms::applyAdjustedRtime(featData)
  # }



#' @title refinePeaks
#' @description Refines chromatographic peaks
#'
#' @param peaksData The \linkS4class{OnDiskMSnExp} object generated by the \code{\link{importRawData}} function.
#' @param expandRt Time (in seconds) to expand the peak width to merge neighboring peaks.
#' @param minProp The proportion (between 0 and 1) representing the proporion of intensity to be required for peaks to be joined.
#' @param expandMz Decreases the minimum and increases the maximum \emph{m/z} by a fixed given value.
#' @param ppm Decreases the minimum and increases the maximum \emph{m/z} by a fixed given value, in ppm.
#' @param maxPeakwidth The maximum width allowed for a peak, in seconds.
#' @param save Logical, set to \code{TRUE} to save the generated list of \code{XCMSnExp} objects in the disk.
#' @param projPath The \code{projPath} directory as defined in the \code{setup} object.
#' @param maxMultiProcess Logical, set to \code{TRUE} to enable max parallel processing. Changes the number of workers to the maximum available.
#'
#' @return A \code{list} of \linkS4class{XCMSnExp} objects with length equal to the number of replicate groups defined in the \code{setup}.
#' The \code{list} is named with the name given to the sample replicate groups.
#'
#' @note See parameters in \code{?refineChromPeaks} from \code{xcms} for more information when \code{refinePeaks} is set to \code{TRUE}.
#'
#' @references
#' \insertRef{MSnbase1}{ntsIUTA}
#' \insertRef{MSnbase2}{ntsIUTA}
#' \insertRef{xcms1}{ntsIUTA}
#' \insertRef{xcms2}{ntsIUTA}
#' \insertRef{xcms3}{ntsIUTA}
#'
#' @export
#'
#' @importFrom BiocParallel registered register bpparam
#' @importClassesFrom BiocParallel SnowParam
#' @importFrom parallel detectCores
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @importClassesFrom xcms MergeNeighboringPeaksParam CleanPeaksParam
#' @importMethodsFrom xcms findChromPeaks refineChromPeaks
#' @importMethodsFrom MSnbase filterFile
#'
#' @examples
#'
refinePeaks <- function(peaksData,
                        expandRt = 1, minProp = 0.9, expandMz = 0, ppm = 0, maxPeakwidth = NULL,
                        save = TRUE, projPath = setup$projPath, maxMultiProcess = TRUE) {

  mpp <- xcms::MergeNeighboringPeaksParam(expandRt = expandRt, minProp = minProp, expandMz = expandMz, ppm = ppm)
  peaksData[[groups[rgidx]]] <- xcms::refineChromPeaks(peaksData[[groups[rgidx]]],
                                                        mpp, msLevel = 1, BPPARAM = BiocParallel::bpparam("SnowParam"))
  if (!base::is.null(maxPeakwidth)) {
    peaksData[[groups[rgidx]]] <- xcms::refineChromPeaks(peaksData[[groups[rgidx]]],
                                                    param = xcms::CleanPeaksParam(maxPeakwidth = maxPeakwidth),
                                                    msLevel = 1L, BPPARAM = BiocParallel::bpparam("SnowParam"))
  }
}



#' @title makeFeatures
#' @description The \code{makeFeatures} consists of alignment and grouping of chromatographic peaks across samples.
#' The function uses methods from the package \pkg{xcms}, specifically \code{\link[xcms]{adjustRtime}} and \code{\link[xcms]{groupChromPeaks}}
#' methods. The input is a \linkS4class{XCMSnExp} object or a \code{list} of \linkS4class{XCMSnExp} objects
#' named with the given sample replicate group during the \code{setup}. If the input is a \code{list}, \linkS4class{XCMSnExp} objects
#' are concatenated to produce a merged \linkS4class{XCMSnExp} object,
#' containing features (\emph{i.e.} grouped chromatographic peaks across samples).
#'
#' @param peaksData A \linkS4class{XCMSnExp} object or a \code{list} of \linkS4class{XCMSnExp} objects named according to the 
#' sample replicate group represented by each \linkS4class{XCMSnExp} object as obtained by \code{\link{peakPicking}}.
#' @param paramPreGrouping If \code{\link[xcms]{adjustRtime}} is preformed with the method \code{PeakGroups},
#' a pre-grouping of peaks is required for alignment. The \code{paramPreGrouping} is the parameters obtained by the selected grouping method.
#' See documentation of \code{\link[xcms]{groupChromPeaks}} for more information.
#' @param paramAlignment The parameters for the chosen alignment method. See documentation of \code{\link[xcms]{adjustRtime}} for more information.
#' @param paramGrouping The parameters for the chosen grouping method.
#' See documentation of \code{\link[xcms]{groupChromPeaks}} for more information.
#' @param ppmForFillingGroups The mass (in ppm) to expand the \emph{mz} for filling missing peaks in incomplete features.
#' See \code{\link[xcms]{fillChromPeaks}} for more information.
#' @param save Logical, set to \code{TRUE} to save the generated \code{XCMSnExp} object in the disk.
#' @param projPath The \code{projPath} directory as defined in the \code{setup} object.
#' @param maxMultiProcess Logical, set to \code{TRUE} to enable max parallel processing. Changes the number of workers to the maximum available.
#'
#' @return An \linkS4class{XCMSnExp} containing features which are grouped and aligned peaks across samples.
#' 
#'  @references
#' \insertRef{xcms1}{ntsIUTA}
#' \insertRef{xcms2}{ntsIUTA}
#' \insertRef{xcms3}{ntsIUTA}
#' 
#' @export
#' 
#' @importFrom BiocParallel registered SnowParam register bpparam
#' @importFrom parallel detectCores
#' @importFrom xcms sampleGroups groupChromPeaks adjustRtime fillChromPeaks ChromPeakAreaParam
#'
#' @examples
#' 
#' 
#' 
makeFeatures <- function(peaksData = peaksData,
                         paramPreGrouping = instParam$preGrouping,
                         paramAlignment = instParam$alignment,
                         paramGrouping = instParam$grouping,
                         ppmForFillingGroups = 5,
                         save = TRUE, projPath = setup$projPath, maxMultiProcess = TRUE) {
  
  #Examples
  #setup <- ntsIUTA::makeSetup(projPath = system.file(package = "ntsIUTA", dir = "extdata"), save = FALSE)
  # setup$sampleInfo[1:3,"group"] <- "Sample"
  # rawDataExample <- ntsIUTA::importRawData(setup$sampleInfo[1:3,], save = FALSE, centroidedData = TRUE)
  # peaksDataExample <- ntsIUTA::peakPicking(rawDataExample, param = param, save = FALSE)
  # paramList <- paramListExample
  # instParam <- getInstParam(paramList)
  # peaksDataExample <- ntsIUTA::peakPicking(rawDataExample, param = instParam$PP, save = FALSE)
  # featDataExample <- ntsIUTA::makeFeatures(peaksDataExample, paramPreGrouping = instParam$preGrouping, paramAlignment = instParam$alignment, paramGrouping = instParam$grouping, save = FALSE)
  # featDataExample
  
  
  
  # require(xcms)
  # require(BiocParallel)
  # require(parallel)
  # require(grDevices)
  # require(RColorBrewer)
  # require(dplyr)
  # require(graphics)
  
  #Enable full parallel processing
  if (maxMultiProcess)
  {
    snow <- BiocParallel::registered("SnowParam")
    if (snow$workers < parallel::detectCores())
    {
      snow <- BiocParallel::SnowParam(workers = parallel::detectCores(), type = "SOCK", exportglobals = FALSE)
      BiocParallel::register(snow, default = TRUE)
    }
  }
  
  
  #Concatenation for peaksData objects before grouping
  if (base::class(peaksData) == "XCMSnExp")
  {
    peaksDataUnified <- peaksData
  } else {
    
    if (base::length(peaksData) == 1)
    {peaksDataUnified <- peaksData[[1]]}
    else {peaksDataUnified <- base::do.call(c, base::unlist(peaksData, recursive = FALSE))}
    
  }
  
  if (base::length(peaksDataUnified$sample_name) > 1) {
    
    #Pregrouping necessary for alignment with PeakGroups method from xcms
    if(base::class(paramAlignment) == "PeakGroupsParam")
    {
      xcms::sampleGroups(paramPreGrouping) <- peaksDataUnified$sample_group
      featData <- xcms::groupChromPeaks(peaksDataUnified, param = paramPreGrouping)
    }
    
    
    featData <- xcms::adjustRtime(featData, msLevel = 1, param = paramAlignment)
    
    xcms::sampleGroups(paramGrouping) <- peaksDataUnified$sample_group
    featData <- xcms::groupChromPeaks(featData, param = paramGrouping)
    
  } else {
    
    xcms::sampleGroups(paramGrouping) <- peaksDataUnified$sample_group
    featData <- xcms::groupChromPeaks(peaksDataUnified, param = paramGrouping)
    
  }
  
  #Fill missing peaks in feature groups
  #Old parameter used: FillChromPeaksParam(ppm = ppmForFillingGroups)
  featData <- base::suppressWarnings(xcms::fillChromPeaks(featData, param = xcms::ChromPeakAreaParam(),
                                                          BPPARAM = BiocParallel::bpparam("SnowParam")))
  
  # add optinally to apply correction of retention time, avoiding another function from xcms
  # if (length(peaksDataUnified$sample_name) > 1) {
  #   featData <- xcms::applyAdjustedRtime(featData)
  # }
  
  if (save)
  {
    rData <- base::paste0(projPath,"\\rData")
    if (!base::dir.exists(rData)) base::dir.create(rData)
    base::saveRDS(featData, file = base::paste0(rData,"\\featData.rds"))
  }
  
  return(featData)
}







#' @title getInstParam
#' @description Tranforms the list of parameters for peak picking (PP), alignment (\emph{i.e.} retention time adjustment across samples)
#' and grouping into the respetive class objects.
#' As input a list as follows should be given where for each data processing step the input should be given as described in
#' the documentation of the aimed function of the \pkg{xcms} package.
#' \itemize{
#'   \item \code{paramList <- list(PP = list("..."), preGrouping = list("..."), alignment = list("..."), grouping = list("..."))}
#' }
#' \code{preGrouping} is used for \code{\link[xcms]{adjustRtime}} function
#' when using the method \code{PeakGroups} as it requires peaks groups (\emph{i.e.} features) for alignment.
#' Note that currently for PP only \code{MassifquantParam} is possible, for alignment only \code{PeakGroupsParam} is possible
#' and for grouping only \code{PeakDensityParam}. Other methods will be integrated in the future.
#' 
#' @param paramList A list of parameters for PP, alignment and grouping as described above.
#' See \code{\link{paramListExample}} object for a structure example.
#'
#' @return A \code{list} with parameters for PP, aligment and grouping to be passed to \code{\link{peakPicking}} and \code{\link{makeFeatures}}. 
#' 
#'  @references
#' \insertRef{xcms1}{ntsIUTA}
#' \insertRef{xcms2}{ntsIUTA}
#' \insertRef{xcms3}{ntsIUTA}
#' 
#' @export
#'
#' @examples
#' paramList <- ntsIUTA::paramListExample
#' getInstParam(paramList)
#' 
getInstParam <- function(paramList = paramList) {
  
  instParam <- list()
  
  instParam$PP <- NULL
  
  # Make instParam for PP
  if(!is.null(paramList$PP)) {
    
    if(paramList$PP$funcName == class(xcms::MassifquantParam())) {
      
      instParam$PP <- xcms::MassifquantParam(ppm = paramList$PP$ppm,
                                             peakwidth = paramList$PP$peakwidth,
                                             snthresh = paramList$PP$snthresh,
                                             prefilter = paramList$PP$prefilter,
                                             mzCenterFun = paramList$PP$mzCenterFun,
                                             integrate = paramList$PP$integrate,
                                             mzdiff = paramList$PP$mzdiff,
                                             fitgauss = paramList$PP$fitgauss,
                                             noise = paramList$PP$noise,
                                             criticalValue = paramList$PP$criticalValue,
                                             consecMissedLimit = paramList$PP$consecMissedLimit,
                                             unions = paramList$PP$unions,
                                             checkBack = paramList$PP$checkBack,
                                             withWave = paramList$PP$verboseColumns,
                                             verboseColumns = paramList$PP$verboseColumns)
      
    }
    
    #Add parameters for other methods
    
  }
  
  instParam$preGrouping <- NULL
  instParam$alignment <- NULL
  
  # Make instParam for alignment, including preGrouping for PeakGroupsParam method
  if(!is.null(paramList$alignment)) {
    
    if(paramList$alignment$funcName == class(xcms::PeakGroupsParam())) {
      
      instParam$preGrouping <-  xcms::PeakDensityParam(sampleGroups = "placeHolder",
                                                       bw = paramList$preGrouping$bw,
                                                       minFraction = paramList$preGrouping$minFraction,
                                                       minSamples = paramList$preGrouping$minSamples,
                                                       binSize = paramList$preGrouping$binSize,
                                                       maxFeatures = paramList$preGrouping$maxFeatures)
      
      instParam$alignment <- xcms::PeakGroupsParam(minFraction = paramList$alignment$minFraction,
                                                   extraPeaks = paramList$alignment$extraPeaks,
                                                   smooth = paramList$alignment$smooth,
                                                   span = paramList$alignment$span,
                                                   family = paramList$alignment$family,
                                                   peakGroupsMatrix = matrix(nrow = 0, ncol = 0),
                                                   subset = integer(),
                                                   subsetAdjust = "average")
      
    }
    
    #Add parameters for other methods
    
  }
  
  instParam$grouping <- NULL
  
  #Make instParam for grouping.
  if(!is.null(paramList$grouping)) {
    
    if(paramList$grouping$funcName == class(xcms::PeakDensityParam(sampleGroups = "placeHolder"))) {
      
      instParam$grouping <- PeakDensityParam(sampleGroups = "placeHolder",
                                             bw = paramList$grouping$bw,
                                             minFraction = paramList$grouping$minFraction,
                                             minSamples = paramList$grouping$minSamples,
                                             binSize = paramList$grouping$binSize,
                                             maxFeatures = paramList$grouping$maxFeatures)
      
    }
    
    #Add parameters for other methods
    
  }
  
  return(instParam)
  
}



### paramList -----

# paramListExample <- list(
#   
#   instName = "Generic",
#   
#   PP = list(
#     funcName = "MassifquantParam",
#     ppm = 20,
#     peakwidth = c(8, 60),
#     snthresh = 3,
#     prefilter = c(6, 500),
#     mzCenterFun = "wMean",
#     integrate = 1,
#     mzdiff = -0.001,
#     fitgauss = TRUE,
#     noise = 200,
#     criticalValue = 1.5,
#     consecMissedLimit = 2,
#     unions = 1,
#     checkBack = 1,
#     withWave = TRUE,
#     verboseColumns = TRUE
#   ),
#   
#   preGrouping = list(
#     funcName = "PeakDensityParam",
#     bw = 5,
#     minFraction = 0.5,
#     minSamples = 1,
#     binSize = 0.003,
#     maxFeatures = 100
#   ),
#   alignment = list(
#     funcName = "PeakGroupsParam",
#     minFraction = 1,
#     extraPeaks = 0,
#     smooth = "loess",
#     span = 0.2,
#     family = "gaussian"
#   ),
#   grouping = list(
#     funcName = "PeakDensityParam",
#     bw = 3,
#     minFraction = 0.5,
#     minSamples = 1,
#     binSize = 0.003,
#     maxFeatures = 100
#   ),
#   componentization = list(
#     
#   )
# )


#additional function for ploting adepted XIC from MSnbase 
.vertical_sub_layout_ex <- function(x, sub_plot = 2) {
  sqrt_x <- base::sqrt(base::length(x))
  ncol <- base::ceiling(sqrt_x)
  nrow <- base::round(sqrt_x)
  rws <- base::split(1:(ncol * nrow * sub_plot), f = base::rep(1:nrow, each = sub_plot * ncol))
  base::do.call(rbind, base::lapply(rws, matrix, ncol = ncol))
}



#additional function for ploting adepted XIC from MSnbase
.plotXIC_ex <- function(x, main = "", col = "white", colramp = colorRampPalette(c("#383E47", "#5E8CAA", "#16B9E5", "#16E5C9", "#16E54C")), #topo.colors colorRampPalette(rev(RColorBrewer::brewer.pal(7,"RdGy")))
                        grid.color = "lightgrey", pch = 21,
                        layout = base::matrix(1:2, ncol = 1), plotTargetMark = plotTargetMark,...) {
  # start edit
  plot_strip <- function(..., v, h) base::plot(...)
  dots <- base::list(...)
  #print(list(...))
  # end edit
  
  if (!plotTargetMark)
  {
    dots$h <- NULL
    dots$v <- NULL
  }
  
  targetColor <- "#0644E9"
  
  if (base::is.matrix(layout))
    graphics::layout(layout)
  
  ## Chromatogram.
  bpi <- base::unlist(base::lapply(base::split(x$i, x$rt), max, na.rm = TRUE))
  brks <- lattice::do.breaks(base::range(x$i), nint = 256)
  graphics::par(mar = c(0, 4, 2, 1))
  
  # start edit
  plot_strip(base::as.numeric(base::names(bpi)), bpi, xaxt = "n", col = col, main = main,
             bg = lattice::level.colors(bpi, at = brks, col.regions = colramp), xlab = "",
             pch = pch, cex = 1.5, ylab = "", las = 2, ...)
  # end edit
  
  if(!is.null(dots$v)) graphics::abline(v=dots$v,col=targetColor,lty=3)
  
  graphics::mtext(side = 4, line = 0, "Intensity", cex = graphics::par("cex.lab"))
  graphics::grid(col = grid.color)
  graphics::par(mar = c(3.5, 4, 0, 1))
  
  # start edit
  plot_strip(x$rt, x$mz, main = "", pch = pch, col = col, xlab = "", ylab = "", cex = 1.5,
             yaxt = "n", bg = lattice::level.colors(x$i, at = brks, col.regions = colramp),
             ...)
  
  if(!is.null(dots$h)) graphics::abline(h=dots$h,col=targetColor,lty=3)
  if(!is.null(dots$v)) graphics::abline(v=dots$v,col=targetColor,lty=3)
  
  if(!is.null(dots$v) & !is.null(dots$h))
  {
    graphics::rect(dots$v-10, dots$h-((5/1E6)*dots$h), dots$v+10, dots$h+((5/1E6)*dots$h),
                   col = NA, lty = 2, border = targetColor)
  }
  # end edit
  
  graphics::axis(side = 2, las = 2)
  graphics::grid(col = grid.color)
  graphics::mtext(side = 1, line = 2.5, "Retention time (sec.)", cex = par("cex.lab"))
  graphics::mtext(side = 4, line = 0, "m/z", cex = par("cex.lab"))
  
}


#' @title plotRawChrom_old
#' @description Plot BPC or TIC chromatograms of an \linkS4class{OnDiskMSnExp} object.
#'
#' @param x An \linkS4class{OnDiskMSnExp} object with one or more files.
#' @param fileIndex The index of the file/s to extract the centroids or profile data.
#' @param mz Optional target \emph{m/z} to obtain an extracted ion chromatogram (EIC).
#' @param ppm The mass deviation to extract the data for the EIC in \code{ppm}.
#' @param rt The retention time in minutes or seconds, depending on the defined \code{rtUnit}, see below.
#' @param rtWindow The time deviation to collect centroids or profile data. The time unit is the defined by \code{rtUnit}.
#' A time interval can be given with a length 2 vector, defining the minimum and maximum retention time.
#' @param rtUnit Possible entries are \code{min} or \code{sec}. The default is \code{sec}.
#' @param msLevel The MS level to extract the data. POssible values are 1 or 2.
#' @param type The type of chromatogram. Possible entries are "bpc" of base peak chromatogram or "tic" for total ion chromatogram.
#' The default is "tic".
#'
#' @return A plot.
#'
#' @examples
#' 
#' plotRawChrom_old(ntsIUTA::rawDataExample)
#' 
#' 
plotRawChrom_old <- function(x = rawData, fileIndex = NULL,
                             mz = NULL, ppm = 20,
                             rt = NULL, rtWindow = NULL,
                             rtUnit = "min",
                             msLevel = 1, type = "tic") {
  
  require(magrittr)
  
  if (rtUnit == "min") if (!is.null(rt)) rt <- rt*60
  if (rtUnit == "min") if (!is.null(rtWindow)) rtWindow <- rtWindow*60
  
  if (!base::is.null(fileIndex)) {x <- MSnbase::filterFile(x, fileIndex)}
  
  rtr <- c(base::min(MSnbase::rtime(x)), base::max(MSnbase::rtime(x)))
  mzr <- NULL
  if (!is.null(mz)) {
    
    if (length(mz) == 1) { mzr <- c(mz - ((ppm/1E6)*mz), mz + ((ppm/1E6)*mz)) }
    if (length(mz) == 2) { mzr <- c(mz[1], mz[2]) }
    
  }
  
  if (!is.null(rt)) { rtr <- c((rt) - ifelse(!is.null(rtWindow), rtWindow, 1), (rt) + ifelse(!is.null(rtWindow), rtWindow, 1)) }
  if (is.null(rt)) if (unique(!is.null(rtWindow))) if (length(rtWindow) == 2) { rtr <- c(rtWindow[1], rtWindow[2]) }
  
  colors <- getColors(x, "samples")
  
  if (is.null(mzr)) {
    chrom <- MSnbase::chromatogram(x, aggregationFun = base::ifelse(type == "bpc", "max", base::ifelse(type == "tic", "sum", stop("Unkown type, please use bpc or tic."))), rt = rtr, msLevel = msLevel)
  } else {
    chrom <- MSnbase::chromatogram(x, aggregationFun = base::ifelse(type == "bpc", "max", base::ifelse(type == "tic", "sum", stop("Unkown type, please use bpc or tic."))), rt = rtr, mz = mzr, msLevel = msLevel)
  }
  
  if (!base::is.null(mzr))
  {
    main <- base::paste0("EIC of ", round(mz, digits = 4)," +/- ", round(ppm, digits = 0)," ppm")
  } else {
    main <- base::toupper(type)
  }
  
  # graphics::layout(base::matrix(1:1))
  # graphics::par(mar=c(5,4,4,2)+0.1)
  
  plot <- MSnbase::plot(chrom, col = colors, lwd = 0.5, main = main, xlab = "Retention time (sec.)", ylab = "Intensity",)
  
  plot <- plot %>% graphics::legend("topleft" , legend = x$sample_name, col = colors, lty = 1, lwd = 2, cex = 0.6, bty = "n", xjust = 0)
  
  
  return(plot)
  
}




#' @title makeSetup
#' @description Project setup by screening a given folder for MS files or
#' by creating a new folder where the MS files can be added using \code{addFiles}.
#' Setting \code{createRproject} to \code{TRUE} will create and open an R project in the selected or given folder.
#' When \code{convertFiles} is \code{TRUE} the function uses \code{\link{mzMLconverter}} to automatically convert specified raw MS files to mzML.
#' 
#'
#' @param projPath The directory for the project. The default is the \code{utils::choose.dir()} to select or create a folder.
#' Note that the function will look into subfolders for mzML files or specified raw files when \code{convertFiles} is set to \code{TRUE}.
#' @param date The project date. The default is the system date generated by \code{\link[base]{Sys.time}}.
#' @param groups A vector with the identifier/name of each sample replicate group. If \code{NULL},
#' a grouping tentative will be made using the name of the MS files found in the given \code{projPath}.
#' @param blanks The name of the sample replicate group to be used for blank subtraction.
#' Different blank groups can be assigned to replicate sample groups by editing the \code{sampleInfo} in the output \code{setup} list.
#' @param polarity A vector specifying the polarity mode used in each MS file.
#' Possible values are \code{positive} or \code{negative} for positive and negative mode, respectively.
#' @param convertFiles Logical, set to \code{TRUE} for non mzML MS files being converted to centroided mzML.
#' The default is \code{FALSE} for no conversion even if files are present.
#' @param convertFrom The name of the file format or vendor format to be found and converted.
#' Possible entries are: \emph{thermo}, \emph{bruker}, \emph{agilent}, \emph{ab} (from AB Sciex) and \emph{waters}.
#' @param convertToCentroid Logical, set to \code{TRUE} to convert profile data to centroided. The default and recommended is \code{TRUE}.
#' @param save Logical, set to \code{TRUE} to save the object setup in the \strong{rData} folder.
#' If \strong{rData} folder does not exist in given \code{projPath}, the folder will be created.
#' @param makeNewProject Logical, set to TRUE to create an R project in the given \code{projPath} and open a new R session.
#'
#' @return The output is a simple list, containing: (1) \code{projPath}, the chosen project path; (2) the \code{date}, the given project date; and 
#' (3) the \code{sampleInfo}, a \code{\link[base]{data.frame}} with the following columns:
#' (1) \code{filePath}, the path of each mzML file, including any converted MS files;
#' (2) \code{sample}, the retrieved file name to be used as sample identifier;
#' (3) \code{group}, the name of each replicate sample group
#' (e.g. samples with the same name but with different numbering, such as in the case of replicate samples);
#' (4) \code{blank}, the specified blank group names or the blank group detected by file name (\emph{i.e.} blank, Blank and/or B as file name);
#' and (5) \code{polarity}, the polarity mode used for each sample, possible entries are \code{positive} and \code{negative};
#' 
#' 
#' @details The data.frame \code{sampleInfo} in the output list can always be edited for correction of
#' sample replicate group names, blank replicate groups and assigned polarity, which is set to \code{positive} by default when not given as argument.
#' 
#' @export
#'
#' @importFrom tools file_path_sans_ext
#' @importFrom dplyr mutate
#' @importFrom rstudioapi initializeProject openProject
#'
#' @examples
#' 
#' 
#' 
setupProject <- function(projPath = utils::choose.dir(base::getwd(), "Select or create a project folder"),
                         date = base::Sys.Date(),
                         groups = NULL,
                         blanks = NULL,
                         polarity = "positive",
                         convertFiles = FALSE,
                         convertFrom = NULL,
                         convertToCentroid = TRUE,
                         save = TRUE,
                         makeNewProject = FALSE) {
  
  #Examples
  # projPath <-  system.file(package = "ntsIUTA", dir = "extdata")
  # setup <- setupProject(projPath = projPath, save = FALSE)
  # setup
  
  
  setup <- base::list()
  setup$projPath  <- projPath
  setup$date <- date
  
  #Create holder for list of samples
  sampleInfo <- base::data.frame(filePath = base::as.character(), sample = base::as.character(),
                                 group = base::as.character(), blank = base::as.character())
  
  
  if (convertFiles)
  {
    if (!base::is.null(convertFrom))
      ntsIUTA::mzMLconverter(path = projPath, convertFrom = convertFrom, centroidData = centroidData)
    else { stop("Vendors should be specified for file recognition. Possible entries are: thermo, bruker, agilent,
                 ab (from AB Sciex) and waters.") }
  }
  
  
  #Screen for MS files in project folder and add info to sampleInfo
  msFiles <- base::list.files(path = projPath, pattern = ".mzML|.mzXML", recursive = TRUE, full.names = TRUE, no.. = TRUE)
  
  if (base::length(msFiles) == 0)
  {
    warning("No mzML or mzXML files were found in selected project path. Use addFiles() to add files to project.")
    
    #Adds files info to sample data frame
  } else {
    sampleInfo[1:base::length(msFiles),] <- NA
    sampleInfo$filePath <- msFiles #base::dirname(msFiles)
    sampleInfo$sample <- tools::file_path_sans_ext(base::basename(msFiles))
    sampleInfo$blank <- blanks
    
    if (base::length(groups) < 2 & base::is.null(groups))
    {
      sampleInfo$group <- tools::file_path_sans_ext(base::basename(msFiles))
      #tentative to group samples and add blank group
      sampleInfo <- dplyr::mutate(sampleInfo, group = base::ifelse(base::grepl("A-r|qc|QC", sampleInfo$sample), "QC", group))
      sampleInfo <- dplyr::mutate(sampleInfo, group = base::ifelse(base::grepl("Blank|blank|B-r", sampleInfo$sample), "Blank", group))
      
    } else sampleInfo$group <- groups
    
    if (base::length(blanks) < 2 & base::is.null(blanks)) sampleInfo$blank <- base::ifelse("Blank" %in% sampleInfo$group, "Blank", NA)
    
    sampleInfo$polarity <- polarity
    
    setup$sampleInfo <- sampleInfo
  }
  
  
  if (save) # Add possibility to move the R project file 
  {
    rData <- base::paste0(projPath,"\\rData")
    
    if (base::dir.exists(rData))
    {
      base::saveRDS(setup, file = base::paste0(rData,"\\setup.rds"))
    } else {
      base::dir.create(rData)
      base::saveRDS(setup, file = base::paste0(rData,"\\setup.rds"))
    }
  }
  
  
  if (makeNewProject)
  {
    # add template for main script file
    sp <- base::file.path(projPath,"mainScript.R")
    base::cat(
      
      "#Copy template from template.R using x and/or use ?ntsIUTA for a tutorial.\n
#Run the following code to load the project setup:\n
library(ntsIUTA) #/n
setup <- readRDS('rData/setup.rds')",
      
      file = sp, sep = "")
    rstudioapi::initializeProject(projPath)
    rstudioapi::openProject(projPath, newSession = TRUE)
    base::print("Run  rstudioapi::navigateToFile('mainScript.R')  in the new project to open the mainScript.R file.")
  }
  
  return(setup)
  
}

