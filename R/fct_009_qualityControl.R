

#' @title checkQC
#' @description Function to check QC samples in \code{rawData}.
#' 
#' @param rawQC An \linkS4class{OnDiskMSnExp} object corresponding to the QC samples.
#' The function \code{filterFile} from \code{MSnbase} can be used to subset the \code{rawData}, such as \code{MSnbase::filterFile(rawData, file = 4:6)}.
#' @param sampleInfo The \code{sampleInfo} data frame generated by \code{\link{makeSetup}} function.
#' @param screeningList A \code{data.frame} with details from each standard in the QC samples.
#' See details for more information about the required data.frame structure.
#' @param paramPeaks The parameters for the choosen peak picking method.
#' See documentation of \code{\link[xcms]{chromatographic-peak-detection}} for more information. 
#' @param paramPreGrouping If \code{\link[xcms]{adjustRtime}} is preformed with the method \code{PeakGroups},
#' a pre-grouping of peaks is required for alignment. The \code{paramPreGrouping} is the parameters obtained by the selected grouping method.
#' See documentation of \code{\link[xcms]{groupChromPeaks}} for more information.
#' @param paramAlignment The parameters for the choosen alignment method. See documentation of \code{\link[xcms]{adjustRtime}} for more information.
#' @param paramGrouping The parameters for the choosen grouping method.
#' See documentation of \code{\link[xcms]{groupChromPeaks}} for more information.
#' @param ppmForFillingGroups The mass (in ppm) to expand the \emph{mz} for filling missing peaks in imcomplete features.
#' See \code{\link[xcms]{fillChromPeaks}} for more information.
#' @param rtWindow The retention time deviation, in seconds, allowed to screen for QC reference standards.
#' @param ppmWindow The mass deviation, in ppm, allowed to screen for QC reference standards.
#' @param polarity The acquisition polarity of the QC samples. Possible values are \code{positive} or \code{negative}.
#' @param plot Logical, set to \code{TRUE} for plotting the results.
#' @param save Logical, set to \code{TRUE} for storing  the generated QC object in the rData folder. 
#' @param projPath The \code{projPath} directory as defined in the \code{setup} object.
#'
#' @details The \code{screeningList} template can be obtained as csv via \code{ntsIUTA::getScreeningListTemplate()}.
#' Add other details of the template.
#'
#' @return A \code{list} containing the plots and a data.frame with the summary of the
#' retention time, mass and intensity deviations as well as the quality of the MS2 data.
#' 
#' @export
#'
#' @import magrittr
#' @importFrom utils read.csv write.csv
#' @importFrom patRoon screenSuspects screenInfo getDefAvgPListParams generateMSPeakLists as.data.table
#' @importFrom dplyr select arrange left_join everything filter mutate top_n
#' @importFrom fuzzyjoin difference_inner_join
#' @importFrom stats cor
#' @importFrom gridExtra arrangeGrob
#' @import ggplot2
#' @importFrom htmlwidgets saveWidget
#' @importFrom plotly partial_bundle
#' @importFrom xcms applyAdjustedRtime
#'
#'
#' @examples
#' 
#' 
#' 
checkQC <- function(rawQC = rawData,
                    sampleInfo = setup$sampleInfo,
                    screeningList = utils::choose.files(base::getwd(), "Select the QC screening list"),
                    paramPeaks = NULL,
                    paramPreGrouping = NULL,
                    paramAlignment = NULL,
                    paramGrouping = NULL,
                    ppmForFillingGroups = 5,
                    rtWindow = 30,
                    ppmWindow = 15,
                    polarity = "positive",
                    plot = TRUE,
                    save = FALSE, projPath = setup$projPath) {
  
  # rawQC = MSnbase::filterFile(rawData, file = 4:6)
  # sampleInfo = setup$sampleInfo
  # screeningList = base::paste0(system.file(package = "ntsIUTA", dir = "extdata"),"/QC_ScreeningList_ntsIUTA_MS2_pos.csv")
  # paramPeaks = param
  # paramPreGrouping = param1
  # paramAlignment = param2
  # paramGrouping = param3
  # ppmForFillingGroups = 5
  # rtWindow = 30
  # ppmWindow = 15
  # polarity = "positive"
  # plot = TRUE
  # save = TRUE
  
  if (base::is.null(rawQC)) stop("rawData of QC samples should be provided using the argument rawQC. See ?checkQC for more information.")
  
  
  qcPeaks <- ntsIUTA::peakPicking(rawQC,
                                  param = param,
                                  removeQC = FALSE,
                                  refinePeaks = FALSE,
                                  save = FALSE)
  
  qcFeat <- ntsIUTA::makeFeatures(peaksData = qcPeaks,
                                  paramPreGrouping = param1,
                                  paramAlignment = param2,
                                  paramGrouping = param3,
                                  ppmForFillingGroups = ppmForFillingGroups,
                                  save = FALSE)
  
  qcFeat <- xcms::applyAdjustedRtime(qcFeat)
  
  qcPat <- ntsIUTA::getPatData(qcFeat, sampleInfo = sampleInfo[sampleInfo$sample %in% qcFeat$sample_name,])
  
  #load or read screeningList
  if (!base::is.data.frame(screeningList)) {
    sl <- utils::read.csv(screeningList)
  } else {
    sl <- screeningList
  }
  if (base::max(sl$rt) < 120) sl$rt <- sl$rt * 60
  
  #check polarity
  if (base::length(polarity) == 1 & !base::is.null(polarity)) {
    adduct <- base::ifelse(polarity == "positive", "[M+H]+", base::ifelse(polarity == "negative", "[M-H]-", stop("polarity argument must be 'positive' or 'negative'")))
  } else {
    stop("polarity argument must be 'positive' or 'negative'")
  }
  
  qcID <- patRoon::screenSuspects(qcPat, dplyr::select(sl, -mz), rtWindow = rtWindow, mzWindow = 0.01, adduct = adduct, onlyHits = TRUE)
  qcdf <- dplyr::arrange(patRoon::as.data.table(qcID, average = TRUE), group)
  qcdf <- dplyr::left_join(qcdf, sl[,base::c("name", "formula", "int10", "hasMS2", "mzMS2", "intMS2", "preMS2")], by = "name")
  qcdf  <- dplyr::left_join(qcdf, dplyr::select(dplyr::arrange(patRoon::screenInfo(qcID), group), group, d_mz, d_rt), by = "group")
  qcdf$av_into <- base::rowMeans(dplyr::select(qcdf, rawQC$sample_name))
  qcdf <- qcdf %>% dplyr::mutate(sd_into = base::apply(dplyr::select(., rawQC$sample_name), 1, sd))
  qcdf <- dplyr::mutate(qcdf, sd_intop = sd_into/av_into*100)
  qcdf$d_ppm <- (base::abs(qcdf$d_mz)/qcdf$mz)*1E6
  qcdf <- dplyr::select(qcdf, name, formula, d_ppm, d_rt, mz, ret, group, dplyr::everything(), -d_mz)
  qcdf<- dplyr::filter(qcdf, d_ppm <= ppmWindow)
  qcdf <- base::as.data.frame(qcdf)
  
  
  control_avgPListParams <- patRoon::getDefAvgPListParams(
    clusterMzWindow = 0.005,
    topMost = 50,
    minIntensityPre = 10,
    minIntensityPost = 10
  )
  
  MS2 <- base::suppressWarnings(patRoon::generateMSPeakLists(
    qcID, "mzr",
    maxMSRtWindow = 5,
    precursorMzWindow = 3,
    avgFeatParams = control_avgPListParams, 
    avgFGroupParams = control_avgPListParams
  ))
  
  
#add MS2 to screening list, adds intensity at 10ng/ml to respective column and adds mz corresponding to the polarity for MS2 matching
  # for (i in 1:nrow(qcdf)) {
  #   xgroup <- qcdf$group[i]
  #   xfrag <- MS2[[xgroup]]$MSMS
  #   
  #   if (!is.null(xfrag)) {
  #     sl$hasMS2[sl$name %in% qcdf$name[i]] <- TRUE
  #     sl$mzMS2[sl$name %in% qcdf$name[i]] <- paste(xfrag$mz, collapse = ";")
  #     sl$intMS2[sl$name %in% qcdf$name[i]] <- paste(xfrag$intensity, collapse = ";")
  #     sl$preMS2[sl$name %in% qcdf$name[i]] <- paste(xfrag$precursor, collapse = ";")
  #   }
  #   
  #   sl$int10[sl$name %in% qcdf$name[i]] <- qcdf$av_into[i]
  #   sl$mz[sl$name %in% qcdf$name[i]] <- sl$neutralMass[sl$name %in% qcdf$name[i]] +  base::ifelse(polarity == "positive",
  #                                                                                                 1.007276, -1.007276)
  # }
  # 
  # utils::write.csv(sl, file = paste0(getwd(),"/inst/extdata/QC_ScreeningList_ntsIUTA_MS2_pos.csv"))
  
  qcdf$nfrag <- 0
  qcdf$pfrag <- 0
  qcdf$intoscore <- 0
  
  for (i in 1:base::nrow(qcdf)) {
    xgroup <- qcdf$group[i]
    xname <- qcdf$name[i]
    if (!base::is.na(xgroup) & qcdf$hasMS2[i]) {
      xMS2 <- MS2[[xgroup]]$MSMS
      if (!base::is.null(xMS2)) {
        dbMS2 <- base::data.frame(mz = base::as.numeric(base::unlist(base::strsplit(qcdf$mzMS2[i], split=";"))),
                                  intensity = base::as.numeric(base::unlist(base::strsplit(qcdf$intMS2[i], split=";"))),
                                  precursor = base::as.logical(base::unlist(base::strsplit(qcdf$preMS2[i], split=";"))))
        
        xMS2 <- dplyr::top_n(xMS2, 10, intensity)
        xMS2 <- dplyr::mutate(xMS2, into_ind = intensity/base::max(xMS2$intensity))
        
        dbMS2 <- dplyr::top_n(dbMS2, 10, intensity)
        dbMS2 <- dplyr::mutate(dbMS2, into_ind = intensity/base::max(dbMS2$intensity))
        
        combi <- fuzzyjoin::difference_inner_join(xMS2, dbMS2, by = c("mz"), max_dist = 0.005, distance_col = "diff")
      
        qcdf$nfrag[i] <- base::nrow(combi)
        qcdf$pfrag[i] <- base::nrow(combi)/base::nrow(dbMS2)
        
        if (qcdf$nfrag[i] == 1) { qcdf$intoscore[i] <- 1 }
        else {
          qcdf$intoscore[i] <- stats::cor(combi$into_ind.x, combi$into_ind.y, use = "everything", method = "pearson")
        }
      } else {
        qcdf$nfrag[i] <- 0
        qcdf$pfrag[i] <- 0
        qcdf$intoscore[i] <- 0
      }
    }
  }
  
  qcdf$pfrag <- base::round(qcdf$pfrag, digits = 2)
  qcdf$intoscore <- base::round(base::as.numeric(qcdf$intoscore), digits = 4)
  
  #TODO Implement isotope check
  
  QC <- list()
  QC[["df"]] <- dplyr::select(qcdf, -hasMS2, -mzMS2, -intMS2, -preMS2)
  
  if (plot) {
    evalPlot <- gridExtra::arrangeGrob(
      ggplot2::ggplot(qcdf) +
        ggplot2::theme_bw() +
        ggplot2::geom_rect(ggplot2::aes(ymin = -10, ymax = 10, xmin = -Inf, xmax = Inf), fill = "ForestGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = -15, ymax = -10, xmin = -Inf, xmax = Inf), fill = "PaleGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = 10, ymax = 15, xmin = -Inf, xmax = Inf), fill = "PaleGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = -Inf, ymax = -15, xmin = -Inf, xmax = Inf), fill = "white", alpha = 0.01) +
        ggplot2::geom_rect(ggplot2::aes(ymin = 15, ymax = Inf, xmin = -Inf, xmax = Inf), fill = "white", alpha = 0.01) +
        ggplot2::geom_point(stat = "identity",
                            ggplot2::aes(x = name,
                       y = d_rt)) +
        ggplot2::theme(axis.title.y = ggplot2::element_blank(),
              axis.text.y = ggplot2::element_text(size = 7),
              axis.text.x = ggplot2::element_text(size = 7),
              axis.title.x = ggplot2::element_text(size = 7)) +
        ggplot2::ylab("RT diff (sec)") +
        ggplot2::ylim(-rtWindow,rtWindow) +
        ggplot2::coord_flip(),
      ggplot2::ggplot(qcdf) +
        ggplot2::theme_bw() +
        ggplot2::geom_rect(ggplot2::aes(ymin = -Inf, ymax = 5, xmin = -Inf, xmax = Inf), fill = "ForestGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = 5, ymax = 10, xmin = -Inf, xmax = Inf), fill = "PaleGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = 10, ymax = Inf, xmin = -Inf, xmax = Inf), fill = "white", alpha = 0.01) +
        ggplot2::geom_point(stat = "identity",
                            ggplot2::aes(x = name,
                       y = d_ppm)) +
        ggplot2::theme(axis.text.y = ggplot2::element_blank(),
              axis.title.y = ggplot2::element_blank(),
              axis.text.x = ggplot2::element_text(size = 7),
              axis.title.x = ggplot2::element_text(size = 7)) +
        ggplot2::ylab("m/z diff (ppm)") +
        ggplot2::ylim(0,ppmWindow) +
        ggplot2::coord_flip(), 
      ggplot2::ggplot(qcdf) +
        ggplot2::theme_bw() +
        ggplot2::geom_rect(ggplot2::aes(ymin = 2, ymax = 5, xmin = -Inf, xmax = Inf), fill = "PaleGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = 5, ymax = Inf, xmin = -Inf, xmax = Inf), fill = "ForestGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = -Inf, ymax = 2, xmin = -Inf, xmax = Inf), fill = "white", alpha = 0.01) +
        ggplot2::geom_point(stat = "identity",
                            ggplot2::aes(x = name,
                       y = nfrag)) +
        ggplot2::theme(axis.text.y = ggplot2::element_blank(),
              axis.title.y = ggplot2::element_blank(),
              axis.text.x = ggplot2::element_text(size = 7),
              axis.title.x = ggplot2::element_text(size = 7)) +
        ggplot2::ylab("Nr Shared Top10 MS2") +
        #ylim(0,10) +
        ggplot2::scale_y_continuous(limits = c(0, 10), breaks = base::seq(0, 10, by = 2)) +
        ggplot2::coord_flip(),
      ggplot2::ggplot(qcdf) +
        ggplot2::theme_bw() +
        ggplot2::geom_rect(ggplot2::aes(ymin = 0.95, ymax = Inf, xmin = -Inf, xmax = Inf), fill = "ForestGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = 0.9, ymax = 0.95, xmin = -Inf, xmax = Inf), fill = "PaleGreen", alpha = 0.05) +
        ggplot2::geom_rect(ggplot2::aes(ymin = -Inf, ymax = 0.9, xmin = -Inf, xmax = Inf), fill = "white", alpha = 0.01) +
        ggplot2::geom_point(stat = "identity",
                            ggplot2::aes(x = name,
                       y = intoscore)) +
        ggplot2::theme(axis.text.y = ggplot2::element_blank(),
              axis.title.y = ggplot2::element_blank(),
              axis.text.x = ggplot2::element_text(size = 7),
              axis.title.x = ggplot2::element_text(size = 7)) +
        ggplot2::ylab("MS2 Intensity Corr.") +
        ggplot2::ylim(0.7,1) +
        ggplot2::coord_flip(),
      ncol = 4, widths = base::c(8,4,4,4))
    
    
    featPlot <- ntsIUTA::plotFeaturePeaks(qcPat, fileIndex = NULL,
                                          features = qcdf$group,
                                          mz = NULL, ppm = NULL,
                                          rt = NULL, rtWindow = NULL,
                                          rtUnit = "min",
                                          plotBy = "features",
                                          names = qcdf$name)
    
    if (save) {
      results <- base::paste0(projPath,"\\results")
      if (!base::dir.exists(results)) base::dir.create(results)
      ggplot2::ggsave(base::paste0(projPath,"/results/QC_Deviations.tiff"),
             plot = evalPlot, device = "tiff", path = NULL, scale = 1,
             width = 17, height = 10, units = "cm", dpi = 300, limitsize = TRUE)
      htmlwidgets::saveWidget(plotly::partial_bundle(plotFeat), file = base::paste0(projPath,"/results/QC_Features.html"))
    }
    
    QC[["featPlot"]] <- featPlot
    QC[["evalPlot"]] <- evalPlot
    
  }
  
  if (save) {
    results <- base::paste0(projPath,"\\results")
    if (!base::dir.exists(results)) base::dir.create(results)
    utils::write.csv(dplyr::select(qcdf, -hasMS2, -mzMS2, -intMS2, -preMS2), file = base::paste0(projPath,"/results/QC_CheckResults.csv"))
    rData <- base::paste0(projPath,"\\rData")
    if (!base::dir.exists(rData)) base::dir.create(rData)
    base::saveRDS(QC, file = base::paste0(rData,"\\QC.rds"))
  }
  
  return(QC)
  
}











