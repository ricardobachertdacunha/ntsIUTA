

#' @title setupProject
#' @description \code{setupProject} takes a given path to create a project for Non-target screening (NTS).
#' MS files in the given path can be directly added to the project or added from a different path after project creation using the function \code{\link{addFiles}}.
#' Setting \code{createRproject} to \code{TRUE} will create and open an R project in the selected or given folder.
#' When \code{convertFiles} is \code{TRUE} the function uses the function \code{\link{mzMLconverter}} to automatically convert specified raw MS files to mzML.
#'
#' @param projPath The directory for project setup. The default is the \code{utils::choose.dir()} to select or create a folder.
#' Note that the function will look into subfolders for mzML files or specified raw files when \code{convertFiles} is set to \code{TRUE}.
#' @param date The project date. The default is the system date generated by \code{\link[base]{Sys.time}}.
#' @param groups A vector with the identifier/name of each sample replicate group. If \code{NULL},
#' a grouping tentative will be made using the name of the MS files found in the given \code{projPath}.
#' @param polarity A vector specifying the polarity mode for the project.
#' Possible values are \code{positive} or \code{negative} for positive and negative modes, respectively.
#' @param convertFiles Logical, set to \code{TRUE} for non mzML MS files being converted to centroided mzML.
#' The default is \code{FALSE} for no conversion even if files are present.
#' @param convertFrom The name of the file format or vendor format to be found and converted.
#' Possible entries are: \emph{thermo}, \emph{bruker}, \emph{agilent}, \emph{ab} (from AB Sciex) and \emph{waters}.
#' @param convertToCentroid Logical, set to \code{TRUE} to convert profile data to centroided when converting raw MS files to mzML.
#' The default and recommended is \code{TRUE}.
#' @param save Logical, set to \code{TRUE} to save the object setup in the \strong{rData} folder.
#' If \strong{rData} folder does not exist in given \code{projPath}, the folder will be created.
#' @param makeNewProject Logical, set to TRUE to create an R project in the given \code{projPath} and open a new R session.
#'
#' @return The output is a \code{dataframe} with the following columns:
#' (1) \code{filePath}, the path of each mzML file, including any converted MS files;
#' (2) \code{sample}, the retrieved file name to be used as sample identifier, possbily subjected to renaming when duplicate names are found;
#' (3) \code{group}, the name of each replicate sample group
#' (e.g. samples with the same name but with different numbering, such as in the case of replicate samples);
#' (4) \code{blank}, the specified blank group names or the blank group detected by file name (\emph{i.e.} blank, Blank and/or B as file name);
#' (5) \code{polarity}, the polarity mode used for each sample, possible entries are \code{positive} and \code{negative};
#' (6) \code{date}, the date of analysis, defaults to current date;
#' and (7) \code{wdir} the working directory of the project, used for meta analysis between different projects;
#'
#' @details The data.frame \code{sampleInfo} in the output list can always be edited for correction of
#' sample replicate group names, blank replicate groups and assigned polarity, which is set to \code{positive} by default when not given as argument.
#'
#' @export
#'
#' @importFrom tools file_path_sans_ext
#' @importFrom dplyr mutate
#' @importFrom rstudioapi initializeProject openProject
#'
#' @examples
#'
setupProject <- function(projPath = utils::choose.dir(getwd(), "Select or create a project folder"),
                         date = as.character(Sys.Date()),
                         groups = NULL,
                         polarity = "positive",
                         convertFiles = FALSE,
                         convertFrom = NULL,
                         convertToCentroid = TRUE,
                         save = TRUE,
                         makeNewProject = FALSE) {
    #Examples
    # projPath <-  system.file(package = "ntsIUTA", dir = "extdata")
    # setup <- setupProject(projPath = projPath, save = FALSE)
    # setup

  sampleInfo <- data.frame(filePath = character(),
                           sample = character(),
                           group = character(),
                           polarity = character(),
                           date = character(),
                           wdir = character())

  if (convertFiles) {
      if (!is.null(convertFrom)) {
          mzMLconverter(path = projPath, convertFrom = convertFrom, centroidData = centroidData)
      } else {
          stop("Vendors should be specified for file recognition. Possible entries are: thermo, bruker, agilent,
                ab (from AB Sciex) and waters.")
      }
  }

  msFiles <- list.files(path = projPath,
                        pattern = ".mzML|.mzXML",
                        recursive = TRUE,
                        full.names = TRUE,
                        no.. = TRUE)

  if (length(msFiles) == 0) {
    warning("No mzML or mzXML files were found in selected project path. Use addFiles() to manually add files to project.")
  } else {
    sampleInfo <- addFiles(newFiles = msFiles,
                           sampleInfo = sampleInfo,
                           copyFiles = FALSE,
                           projPath = projPath,
                           date = date,
                           groups = groups,
                           polarity = polarity)
  }

  if (save) {
    saveObject(projPath = projPath, polarity = polarity, sampleInfo = sampleInfo, date = date)
  }

  if (makeNewProject) {
    #TODO add template for main script file
    sp <- file.path(projPath, "mainScript.R")
    cat(

"#Copy template from template.R using x and/or use ?ntsIUTA for a tutorial.\n
#Run the following code to load the project setup:\n
library(ntsIUTA) #/n
setup <- readRDS('rData/sampleInfo.rds')",

    file = sp, sep = "")

    if (!(is.na(Sys.getenv()["RSTUDIO"]))) {
      rstudioapi::initializeProject(projPath)
      rstudioapi::openProject(projPath, newSession = TRUE)
    } else {
      setwd(projPath)
    }

    print("When not using RStudio, it is recommended to open the project folder in the IDE to load the files and workspace.
                Run  rstudioapi::navigateToFile('mainScript.R')  in the new project to open the mainScript.R file.")

  }

  return(sampleInfo)

}



#' @title addFiles
#' @description Adds mzML or mzXML files to the sampleInfo \code{data.frame} object of the project
#' as defined by the function \code{\link{setupProject}}.
#'
#' @param newFiles A list of paths for selected mzML or mzXML files to be added to the project. The default is a UI to choose the files.
#' @param sampleInfo A sampleInfo \code{data.frame} as created by \code{\link{setupProject}} to add the selected files.
#' @param copyFiles Logical. Set to \code{TRUE} to copied the selected files to the defined \code{path}.
#' \code{FALSE} will add the original location of the files to the sampleInfo.
#' Note that if duplicate names exist, the copied files are renamed or when \code{copyFiles} is \code{FALSE}, the original files will be renamed.
#' @param projPath When \code{copyFiles} is \code{TRUE}, the project \code{path} to copy the files.
#' The default is the working directory of the project given by \code{base::getwd()}.
#' @param date The project date. The default is the system date generated by \code{\link[base]{Sys.time}}.
#' @param groups A vector with the identifier/name of each sample replicate group. If \code{NULL},
#' a grouping tentative will be made using the name of the MS files found in the given \code{path}.
#' @param polarity A vector specifying the polarity mode used in each MS file.
#' Possible values are \code{positive} or \code{negative} for positive and negative mode, respectively.
#'
#' @return Returns an updated sampleInfo \code{dataframe} object.
#'
#' @details The groups, blanks and polarity can be altered afterwards directly on the sampleInfo \code{dataframe} object.
#'
#' @importFrom dplyr semi_join anti_join mutate
#' @importFrom utils choose.files askYesNo
#' @importFrom tools file_ext
#'
#' @export
#'
#' @examples
#'
addFiles <- function(newFiles = utils::choose.files(),
                     sampleInfo = base::data.frame(filePath = character(), sample = character(),
                                                   group = character(), blank = character(),
                                                   polarity = character(), date = character(),
                                                   wdir = character()),
                     copyFiles = FALSE,
                     projPath = base::getwd(),
                     date = base::Sys.Date(),
                     groups = NULL,
                     polarity = "positive") {

  if (base::length(newFiles) < 1) return(sampleInfo)

  tmpInfo <- base::data.frame(filePath = character(), sample = character(),
                              group = character(), blank = character(),
                              polarity = character(), date = character(),
                              wdir = character())

  tmpInfo[base::seq_len(base::length(newFiles)), ] <- NA
  tmpInfo$filePath <- newFiles
  tmpInfo$sample <- base::gsub(".mzML|.mzXML", "", base::basename(newFiles))
  tmpInfo$blank <- "Blank"

  if (base::is.null(groups)) {
    tmpInfo$group <- base::gsub(".mzML|.mzXML", "", base::basename(newFiles))
    tmpInfo <- dplyr::mutate(tmpInfo, group = base::ifelse(base::grepl("A-r|qc|QC", tmpInfo$sample), "QC", group))
    tmpInfo <- dplyr::mutate(tmpInfo, group = base::ifelse(base::grepl("Blank|blank|B-r", tmpInfo$sample), "Blank", group))
  } else {
    tmpInfo$group <- groups
  }

  tmpInfo$polarity <- polarity
  tmpInfo$date <- date
  tmpInfo$wdir <- projPath

  orgJoint <- base::rbind(sampleInfo, tmpInfo)
  duplicates <- base::duplicated(orgJoint$sample)

  duplicateNamesPrompt <- TRUE
  if (TRUE %in% duplicates) {
    duplicateNamesPrompt <- utils::askYesNo("Duplicate filenames found but must be unique, do you want to rename?")
    newJoint <- removeDuplicateNames(newJoint = orgJoint)
  } else {
    newJoint <- orgJoint
  }

  if (!(duplicateNamesPrompt) || base::is.na(duplicateNamesPrompt))  {
      warning("Process aborted due to user input. Names must be renamed for compliance even when copied")
      return(sampleInfo)
  } else {

    newDuplicates <- !(orgJoint$sample == newJoint$sample)

    if (copyFiles) {
      mzML <- base::paste0(projPath, "\\mzML")
      if (!base::dir.exists(mzML)) base::dir.create(mzML)
    }

    for (i in base::seq_len(base::length(newFiles))) {
      i2 <- base::which(newJoint$filePath == newFiles[i])
      ext <- tools::file_ext(newFiles[i])

      if (copyFiles) {
        dir <- mzML
      } else {
        dir <- base::dirname(newJoint$filePath[i2])
      }

      newfilepath <- base::paste(dir, "\\", newJoint$sample[i2], ".", ext, sep = "")

      if (copyFiles) {
        if (!(base::file.exists(newfilepath))) {
        base::file.copy(newFiles[i], newfilepath, overwrite = FALSE)
        } else {
          base::warning(base::paste("File ", newfilepath, " not added because already exists in given directory."))
          newfilepath <- NA
        }
      } else {
        if (newDuplicates[i2]) {
          base::file.rename(newFiles[i], newfilepath)
        }
      }
      newJoint$filePath[i2] <- newfilepath
    }

    newJoint <- newJoint[!base::is.na(newJoint$filePath), ]

    return(newJoint)

  }
}



#' @title addMetadata
#' @description Adds additional information to the sampleInfo \code{data.frame}. For instance,
#' additional information could be concentration data or other known properties or classifiers for each sample in the sampleInfo \code{data.frame}.
#' The added metadata can then be used for inferential and statistical analyses.
#'
#' @param sampleInfo The sampleInfo \code{data.frame} object to be amended with metadata.
#' @param metadata A \code{data.frame} with the same number of rows as the sampleInfo contaninig 1 or more columns with metadata.
#' Note that the column names in the metadata \code{data.frame} will be used as classifiers.
#'
#' @return Returns an updated sampleInfo \code{data.frame} objects.
#'
#' @export
#'
#' @examples
#'
addMetadata <- function(sampleInfo, metadata) {
  if (base::length(sampleInfo) == 0 & base::length(sampleInfo) != base::length(metadata)) {
    base::warning("Please make sure the metadata has the same dimensions as the sample data")
  } else {
    sampleInfo <- base::cbind(sampleInfo, metadata)
  }
  return(sampleInfo)
}



#' @title removeDuplicateNames
#' @description Removes duplicate sample names to avoid problems during further analysis.
#'
#' @param newJoint Original and new sampleInfo \code{data.frame} objects collated by \code{rbind}
#'
#' @return Returns the same \code{data.frame} but with duplicate sample names edited as duplicate sample names are not allowed.
#'
#' @importFrom dplyr semi_join
#' @importFrom stringr str_extract str_pad
#'
removeDuplicateNames <- function(newJoint) {
  duplicates <- base::duplicated(newJoint$sample)
  if (TRUE %in% duplicates) {
    base::print(base::paste("Number of duplicate names found:", base::length(duplicates[duplicates == TRUE]), sep = " "))
    for (i in base::seq_len(base::length(duplicates))) {
      if (duplicates[i]) {
        endOfString <-  stringr::str_extract(newJoint$sample[i], "_[^_]+$")
        startOfString <-  stringr::str_extract(newJoint$sample[i], base::paste("^.*(?=(", endOfString, "))", sep = ""))
        if ((base::grepl("_[0-9]+", endOfString)) && (!base::is.na(endOfString))) {
          endOfString <- base::as.numeric(stringr::str_extract(endOfString, "[0-9]+")) + 1
          endOfString <- stringr::str_pad(endOfString, 2, pad = "0")
          newJoint$sample[i] <- base::paste(startOfString, endOfString, sep = "_")
        } else {
          newJoint$sample[i] <- base::paste(newJoint$sample[i], "_01", sep = "")
        }
      }
    }
    duplicates <- base::duplicated(newJoint$sample)
    if (TRUE %in% duplicates) {
      newJoint <- removeDuplicateNames(newJoint)
    }
  }
  return(newJoint)
}



#' @title mzMLconverter
#' @description Converts raw MS files from different formats to mzML using the external tool \emph{msConvert}
#' from [ProtesWizard](http://proteowizard.sourceforge.net/) through the interface of \pkg{patRoon} \insertCite{Helmus2021}{ntsIUTA}.
#' Possible formats are: \emph{thermo}, \emph{bruker}, \emph{agilent}, \emph{ab} (from AB Sciex) and \emph{waters}.
#'
#' @param path The \code{path} where the files to be converted can be found. The function will look into subfolders.
#' @param files Alternatevely, a list with complete file paths for conversion.
#' Note that this will overwrite the \code{path} argument to look for files. The \code{convertFrom} argument must be anyway given.
#' @param convertFrom The format/vendor of files to be found and converted.
#' Possible entries are: \emph{thermo}, \emph{bruker}, \emph{agilent}, \emph{ab} (from AB Sciex) and \emph{waters}.
#' The default is \emph{agilent}.
#' @param centroidMethod The method for centroiding the data. Possible values are \emph{vendor} (the default) to use the vendor algorithm,
#' \emph{cwt} to use the wavelet algorithm or \code{NULL} for skiping dada centroiding. See [ProtesWizard](http://proteowizard.sourceforge.net/) for more information.
#' @param outPath The path to store the mzML files. When \code{NULL} the \code{path} is used instead.
#' @param overWrite Logical, set to \code{TRUE} to overwrite existing files in the defined storing location (either \code{path} or \code{outPath}).
#'
#' @return The converted files will be saved as mzML in the given \code{path} or \code{outPath}.
#'
#' @references \insertRef{Helmus2021}{ntsIUTA}
#' @references \insertRef{proteo}{ntsIUTA}
#'
#' @export
#'
#' @importFrom patRoon convertMSFiles
#'
#' @examples
#'
mzMLconverter <- function(path = getwd(),
                          files = NULL,
                          convertFrom = "agilent",
                          centroidMethod = "vendor",
                          outPath = NULL,
                          overWrite = FALSE) {

  msFileFilters <- data.frame(type = c("agilent", "thermo", "ab", "waters"),
                              ext =  c(".\\.d$", ".\\.RAW$", ".\\.wiff$", ".\\.RAW$"))

  if (convertFrom %in% msFileFilters$type) {

    if (is.null(files)) {
      fileType <- msFileFilters[msFileFilters$type == convertFrom, "ext", drop = TRUE]
      if (length(fileType) == 1) {
        rawFiles <- list.files(path = path, pattern = fileType,
                                    recursive = TRUE, full.names = TRUE,
                                    no.. = FALSE, include.dirs = TRUE, ignore.case = TRUE)
      } else {
        return(cat("Warning: files with the specified format not found in the given path.
        See ?ntsIUTA::mzMLconverter for information."))
      }

    } else {
      matchfiles <- grepl(pattern = msFileFilters[msFileFilters$type == convertFrom, "ext", drop = TRUE], files)
      if (unique(matchfiles)) {
        rawFiles <- files
      } else {
        return(cat("Warning: one or more files do not match with the specified format.
        See ?ntsIUTA::mzMLconverter for information."))
      }
    }

    if (length(rawFiles) > 1) {
      if (!is.null(centroidMethod) & centroidMethod %in% c("vendor", "cwt")) {
        patRoon::convertMSFiles(files = rawFiles,
                                outPath = ifelse(is.null(outPath), path, outPath),
                                dirs = FALSE,
                                anaInfo = NULL,
                                from = convertFrom,
                                to = "mzML",
                                overWrite = overWrite,
                                algorithm = "pwiz",
                                centroid = centroidMethod,
                                filters = c("msLevel 1-2"),
                                extraOpts = NULL,
                                PWizBatchSize = 1)
        return(cat("done"))

      } else {
        patRoon::convertMSFiles(files = rawFiles,
                                outPath = ifelse(is.null(outPath), path, outPath),
                                dirs = FALSE,
                                anaInfo = NULL,
                                from = convertFrom,
                                to = "mzML",
                                overWrite = overWrite,
                                algorithm = "pwiz",
                                centroid = NULL,
                                filters = NULL,
                                extraOpts = NULL,
                                PWizBatchSize = 1)
        return(cat("done"))
      }
    } else {
      return(cat("No files found with the given format or vendor.
      See ?ntsIUTA::mzMLconverter for information."))
    }


  } else {
    return(cat("Warning: the format given in convertFrom is not recognized.
    See ?ntsIUTA::mzMLconverter for possible data formats."))
  }
}


#' @title saveObject
#' @description Saves project objects in the rData folder,
#' which is created when the \code{save} argument is set to \code{TRUE}.
#'
#' @param projPath The project directory. The default is \code{base::getwd()}.
#' @param polarity The polarity of the project. POssible values are \emph{positive} or \emph{negative}.
#' @param ... The object to be save can be passed as it is.
#' For instance, for the sampleInfo \code{data.frame} it should be \code{sampleInfo = sampleInfo}
#' so that the object name is used as file name. For the function \code{setupProject} the date can be given
#' as \code{date = date} after the sampleInfo to be stored and added to the rds object names.
#'
#' @return Saves the given object in the rData folder of the project.
#'
saveObject <- function(projPath = getwd(), polarity = "positive", ...) {

  rData <- paste0(projPath, "\\rData")
  if (!dir.exists(rData)) dir.create(rData)

  dots <- list(...)

  if ("date" %in% names(dots)) {
    projDate <- gsub(pattern = "-", replacement = "", x = dots[2])
    saveRDS(projDate, file = paste0(rData, "\\", "projDate.rds"))
  }

  if (file.exists(paste0(rData, "\\", "projDate.rds"))) {
    projDate <- readRDS(paste0(rData, "\\", "projDate.rds"))
  } else {
    projDate <- ""
  }

  fileName <- ifelse(polarity == "positive",
                      paste0(names(dots[1]), "_", projDate, "pos"),
                      paste0(names(dots[1]), "_", projDate, "neg"))

  saveRDS(dots[1], file = paste0(rData, "\\", fileName, ".rds"))

}
