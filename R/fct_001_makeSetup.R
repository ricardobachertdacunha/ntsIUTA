

#' @title setupProject
#' @description \code{setupProject} takes a given path to create a project for Non-target screening (NTS).
#' MS files in the given path can be directly added to the project or added from a different path after project creation using the function \code{\link{addFiles}}.
#' Setting \code{createRproject} to \code{TRUE} will create and open an R project in the selected or given folder.
#' When \code{convertFiles} is \code{TRUE} the function uses the function \code{\link{mzMLconverter}} to automatically convert specified raw MS files to mzML.
#'
#' @param projPath The directory for project setup. The default is the \code{utils::choose.dir()} to select or create a folder.
#' Note that the function will look into subfolders for mzML files or specified raw files when \code{convertFiles} is set to \code{TRUE}.
#' @param date The project date. The default is the system date generated by \code{\link[base]{Sys.time}}.
#' @param groups A vector with the identifier/name of each sample replicate group. If \code{NULL},
#' a grouping tentative will be made using the name of the MS files found in the given \code{projPath}.
#' @param blanks The name of the sample replicate group to be used for blank subtraction.
#' Different blank groups can be assigned to replicate sample groups by editing the returned \code{data.frame}.
#' @param polarity A vector specifying the polarity mode used for each MS file.
#' Possible values are \code{positive} or \code{negative} for positive and negative modes, respectively.
#' @param convertFiles Logical, set to \code{TRUE} for non mzML MS files being converted to centroided mzML.
#' The default is \code{FALSE} for no conversion even if files are present.
#' @param convertFrom The name of the file format or vendor format to be found and converted.
#' Possible entries are: \emph{thermo}, \emph{bruker}, \emph{agilent}, \emph{ab} (from AB Sciex) and \emph{waters}.
#' @param convertToCentroid Logical, set to \code{TRUE} to convert profile data to centroided when converting raw MS files to mzML.
#' The default and recommended is \code{TRUE}.
#' @param save Logical, set to \code{TRUE} to save the object setup in the \strong{rData} folder.
#' If \strong{rData} folder does not exist in given \code{projPath}, the folder will be created.
#' @param makeNewProject Logical, set to TRUE to create an R project in the given \code{projPath} and open a new R session.
#'
#' @return The output is a \code{dataframe} with the following columns:
#' (1) \code{filePath}, the path of each mzML file, including any converted MS files;
#' (2) \code{sample}, the retrieved file name to be used as sample identifier, possbily subjected to renaming when duplicate names are found;
#' (3) \code{group}, the name of each replicate sample group
#' (e.g. samples with the same name but with different numbering, such as in the case of replicate samples);
#' (4) \code{blank}, the specified blank group names or the blank group detected by file name (\emph{i.e.} blank, Blank and/or B as file name);
#' (5) \code{polarity}, the polarity mode used for each sample, possible entries are \code{positive} and \code{negative};
#' (6) \code{date}, the date of analysis, defaults to current date;
#' and (7) \code{wdir} the working directory of the project, used for meta analysis between different projects;
#'
#' @details The data.frame \code{sampleInfo} in the output list can always be edited for correction of
#' sample replicate group names, blank replicate groups and assigned polarity, which is set to \code{positive} by default when not given as argument.
#'
#' @export
#'
#' @importFrom tools file_path_sans_ext
#' @importFrom dplyr mutate
#' @importFrom rstudioapi initializeProject openProject
#'
#' @examples
#'
setupProject <- function(projPath = utils::choose.dir(base::getwd(), "Select or create a project folder"),
                         date = base::Sys.Date(),
                         groups = NULL,
                         blanks = NULL,
                         polarity = "positive",
                         convertFiles = FALSE,
                         convertFrom = NULL,
                         convertToCentroid = TRUE,
                         save = TRUE,
                         makeNewProject = FALSE) {
    #Examples
    # projPath <-  system.file(package = "ntsIUTA", dir = "extdata")
    # setup <- setupProject(projPath = projPath, save = FALSE)
    # setup

    sampleInfo <- base::data.frame(filePath = character(),
                                    sample = character(),
                                    group = character(),
                                    blank = character(),
                                    polarity = character(),
                                    date = character(),
                                    wdir = character())

    if (convertFiles) {
        if (!base::is.null(convertFrom)) {
            ntsIUTA::mzMLconverter(path = projPath, convertFrom = convertFrom, centroidData = centroidData)
        } else {
            stop("Vendors should be specified for file recognition. Possible entries are: thermo, bruker, agilent,
                 ab (from AB Sciex) and waters.")
        }
    }

    msFiles <- base::list.files(path = projPath,
                                pattern = ".mzML|.mzXML",
                                recursive = TRUE,
                                full.names = TRUE,
                                no.. = TRUE)

    if (base::length(msFiles) == 0) {
        warning("No mzML or mzXML files were found in selected project path. Use addFiles() to add files to project.")
    } else {
        sampleInfo[base::seq_len(base::length(msFiles)), ] <- NA
        sampleInfo$filePath <- msFiles
        sampleInfo$sample <- tools::file_path_sans_ext(base::basename(msFiles))
        sampleInfo$blank <- blanks

        if (base::length(groups) < 2 & base::is.null(groups)) {
            sampleInfo$group <- tools::file_path_sans_ext(base::basename(msFiles))
            sampleInfo <- dplyr::mutate(sampleInfo, group = base::ifelse(base::grepl("A-r|qc|QC", sampleInfo$sample), "QC", group))
            sampleInfo <- dplyr::mutate(sampleInfo, group = base::ifelse(base::grepl("Blank|blank|B-r", sampleInfo$sample), "Blank", group))
        } else {
            sampleInfo$group <- groups
        }

        if (base::length(blanks) < 2 & base::is.null(blanks)) {
          sampleInfo$blank <- base::ifelse("Blank" %in% sampleInfo$group, "Blank", NA)
        }

        sampleInfo$polarity <- polarity
        sampleInfo$date <- date
        sampleInfo$wdir <- projPath
    }

  if (save) {
    rData <- base::paste0(projPath, "\\rData")
    if (!base::dir.exists(rData)) base::dir.create(rData)
    base::saveRDS(sampleInfo, file = base::paste0(rData, "\\sampleInfo.rds"))
  }

  if (makeNewProject) {
    #TODO add template for main script file
    sp <- base::file.path(projPath, "mainScript.R")
    base::cat(

"#Copy template from template.R using x and/or use ?ntsIUTA for a tutorial.\n
#Run the following code to load the project setup:\n
library(ntsIUTA) #/n
setup <- readRDS('rData/sampleInfo.rds')",

    file = sp, sep = "")

    if (!(base::is.na(base::Sys.getenv()["RSTUDIO"]))) {
      rstudioapi::initializeProject(projPath)
      rstudioapi::openProject(projPath, newSession = TRUE)
    } else {
        base::setwd(projPath)
    }

    base::print("When not using RStudio, it is recommended to open the project folder in the IDE to load the files and workspace.
                Run  rstudioapi::navigateToFile('mainScript.R')  in the new project to open the mainScript.R file.")

  }

  return(sampleInfo)

}



#' @title addFiles
#' @description Adds mzML or mzXML files to the sampleInfo \code{data.frame} object of the project
#' as defined by the function \code{\link{setupProject}}.
#'
#' @param newFiles A list of paths for selected mzML or mzXML files to be added to the project. The default is a UI to choose the files.
#' @param sampleInfo A sampleInfo \code{data.frame} as created by \code{\link{setupProject}} to add the selected files.
#' @param copyFiles Logical. Set to \code{TRUE} to copied the selected files to the defined \code{path}.
#' \code{FALSE} will add the original location of the files to the sampleInfo.
#' Note that if duplicate names exist, the copied files are renamed or when \code{copyFiles} is \code{FALSE}, the original files will be renamed.
#' @param path When \code{copyFiles} is \code{TRUE}, the project \code{path} to copy the files.
#' The default is the working directory of the project given by \code{base::getwd()}.
#' @param date The project date. The default is the system date generated by \code{\link[base]{Sys.time}}.
#' @param groups A vector with the identifier/name of each sample replicate group. If \code{NULL},
#' a grouping tentative will be made using the name of the MS files found in the given \code{path}.
#' @param blanks The name of the sample replicate group to be used for blank subtraction.
#' Different blank groups can be assigned to replicate sample groups by editing the \code{sampleInfo} in the output \code{setup} list.
#' @param polarity A vector specifying the polarity mode used in each MS file.
#' Possible values are \code{positive} or \code{negative} for positive and negative mode, respectively.
#'
#' @return Returns an updated sampleInfo \code{dataframe} object.
#'
#' @details The groups, blanks and polarity can be altered afterwards directly on the sampleInfo \code{dataframe} object.
#'
#' @importFrom dplyr semi_join anti_join mutate
#' @importFrom utils choose.files askYesNo
#' @importFrom tools file_ext
#'
#' @export
#'
#' @examples
#'
addFiles <- function(newFiles = utils::choose.files(),
                     sampleInfo = base::data.frame(filePath = character(), sample = character(),
                                                   group = character(), blank = character(),
                                                   polarity = character(), date = character(),
                                                   wdir = character()),
                     copyFiles = utils::askYesNo("Do you want to copy the analysis files to the project directory?"),
                     path = base::getwd(),
                     date = base::Sys.Date(),
                     groups = NULL,
                     blanks = NULL,
                     polarity = "positive") {

  if (base::is.na(copyFiles)) {
      copyFiles <- FALSE
  }

  tmpInfo <- base::data.frame(filePath = character(), sample = character(),
                              group = character(), blank = character(),
                              polarity = character(), date = character(),
                              wdir = character())

  if (base::length(newFiles) == 0) {
    warning("No mzML or mzXML files were found in selected project path. Use addFiles() to add files to project.")
  } else {
    tmpInfo[base::seq_len(base::length(newFiles)), ] <- NA
    tmpInfo$filePath <- newFiles
    tmpInfo$sample <- base::gsub(".mzML|.mzXML", "", base::basename(newFiles))
    tmpInfo$blank <- blanks

    if (base::length(groups) < 2 & base::is.null(groups))  {
        tmpInfo$group <- base::gsub(".mzML|.mzXML", "", base::basename(newFiles))
        tmpInfo <- dplyr::mutate(tmpInfo, group = base::ifelse(base::grepl("A-r|qc|QC", tmpInfo$sample), "QC", group))
        tmpInfo <- dplyr::mutate(tmpInfo, group = base::ifelse(base::grepl("Blank|blank|B-r", tmpInfo$sample), "Blank", group))
    } else {
        tmpInfo$group <- groups
    }

    if (base::length(blanks) < 2 & base::is.null(blanks)) {
      tmpInfo$blank <- base::ifelse("Blank" %in% tmpInfo$group, "Blank", NA)
    }

    tmpInfo$polarity <- polarity
    tmpInfo$date <- date
    tmpInfo$wdir <- base::getwd()
  }

  newInfo <- removeDuplicateNames(sampleInfo, tmpInfo)

  duplicateNamesPrompt <- TRUE
  if (base::nrow(dplyr::anti_join(newInfo, tmpInfo)) > 0 && copyFiles == FALSE) {
    duplicateNamesPrompt <- utils::askYesNo("Duplicate filenames found but must be unique, do you want to rename?")
  }

  if (!(duplicateNamesPrompt) || base::is.na(duplicateNamesPrompt))  {
      warning("Process aborted due to user input. Please allow either renaming or copying")
      return(sampleInfo)
  } else {

    if (copyFiles) {
      base::print("Copying files to project directory...")
      for (i in base::seq_len(base::nrow(newInfo))) {
        newFileTotalPath <- base::paste(path, "\\", newInfo$sample[i], ".", tools::file_ext(newFiles[i]), sep = "")
        if (!(base::file.exists(newFileTotalPath))) {
          base::file.copy(newFiles[i], newFileTotalPath, overwrite = FALSE)
          base::print(base::paste("Copying file ", newFiles[i], " to ", newFileTotalPath, ".", sep = ""))
          newInfo$filePath[i] <- newFileTotalPath
        } else {
          newInfo$filePath[i] <- NA
          base::warning(paste("File ", newFileTotalPath, " already exist. Try renaming analysis files. Aborting.", sep = ""))
        }
      }
      base::print("Files have been copied to project directory.")

    } else {
      for (i in base::seq_len(base::nrow(newInfo))) {
        base::print("Renaming files if necessary...")
        newFileTotalPath <- base::paste(base::dirname(newInfo$filePath[i]), "\\", newInfo$sample[i], ".", tools::file_ext(newFiles[i]), sep = "")
        if (!(base::file.exists(newFileTotalPath))) {
          base::file.rename(newFiles[i], newFileTotalPath)
          base::print(base::paste("Renaming file ", newFiles[i], " to ", newFileTotalPath, ".", sep = ""))
          newInfo$filePath[i] <- newFileTotalPath
        } else {
          newInfo$filePath[i] <- NA
          base::warning(paste("File ", newFileTotalPath, " already exist. Try renaming analysis files. Aborting.", sep = ""))
        }
      }
    }

    newInfo <- newInfo[!base::is.na(newInfo$filePath), ]
    sampleInfo <- base::rbind(sampleInfo, newInfo)

    return(sampleInfo)

  }
}



#' @title addMetadata
#' @description Adds additional information to the sampleInfo \code{data.frame}. For instance,
#' additional information could be concentration data or other known properties or classifiers for each sample in the sampleInfo \code{data.frame}.
#' The added metadata can then be used for inferential and statistical analyses.
#'
#' @param sampleInfo The sampleInfo \code{data.frame} object to be amended with metadata.
#' @param metadata A \code{data.frame} with the same number of rows as the sampleInfo contaninig 1 or more columns with metadata.
#' Note that the column names in the metadata \code{data.frame} will be used as classifiers.
#'
#' @return Returns an updated sampleInfo \code{data.frame} objects.
#'
#' @export
#'
#' @examples
#'
addMetadata <- function(sampleInfo, metadata) {
  if (base::length(sampleInfo) == 0 & base::length(sampleInfo) != base::length(metadata)) {
    base::warning("Please make sure the metadata has the same dimensions as the sample data")
  } else {
    sampleInfo <- base::cbind(sampleInfo, metadata)
  }
  return(sampleInfo)
}



#' @title removeDupliceNames
#' @description Removes duplicate sample names to avoid problems during further analysis.
#'
#' @param orgInfo Original dataframe where additional entries are to be added
#' @param newInfo Dataframe containing the new samples to be added to the original data.
#' @return Returns a dataframe containing the new entries which changed sample names in case of duplicates.
#'
#' @importFrom dplyr semi_join
#' @importFrom stringr str_extract

removeDuplicateNames <- function(orgInfo, newInfo) {

  if (base::nrow(orgInfo) == 0) {
    return(newInfo)

  } else {

    duplicates <- dplyr::semi_join(orgInfo, newInfo, by = "sample")

    if (base::nrow(duplicates) > 0) {

      print(paste("Number of duplicate names found:", nrow(duplicates), sep = " "))

      for (i in base::seq_len(base::nrow(duplicates))) {
        endOfString <-  stringr::str_extract(duplicates$sample[i], "_[^_]+$")
        startOfString <-  stringr::str_extract(duplicates$sample[i], paste("^.*(?=(", endOfString, "))", sep = ""))
        if ((base::grepl("_[1-9]", endOfString)) && (!base::is.na(endOfString))) {
          print("Changing the names of the samples.")
          endOfString <- base::as.numeric(stringr::str_extract(endOfString, "[0-9]")) + 1
          newInfo$sample <- base::gsub(duplicates$sample[i],
                                        base::paste(startOfString, endOfString, sep = "_"),
                                        newInfo$sample)
        } else {
          matches <- base::grep(duplicates$sample[i], newInfo$sample)
          for (kk in base::seq_len(base::length(matches))) {
            newInfo$sample[matches[kk]] <- base::gsub(paste(duplicates$sample[i], "$", sep = ""),
                                                      base::paste(duplicates$sample[i], kk, sep = "_"),
                                                      newInfo$sample[matches[kk]])
          }
        }
      }

      if (base::nrow(dplyr::semi_join(base::subset(orgInfo, select = 2), base::subset(newInfo, select = 2))) > 0) {
        print("Duplicates found after renaming. Doing recursion.")
        newInfo <- ntsIUTA::removeDuplicateNames(orgInfo, newInfo)
      }

      return(newInfo)

    }
  }
}



#' @title mzMLconverter
#' @description Converts MS files from different formats to mzML format.
#' See \pkg{patRoon} \insertCite{Helmus2021}{ntsIUTA} for all the possible formats.
#' Optionally and recommended, it centroids the data.
#'
#' @param path The \code{path} where the files to be converted can be found. The function will look into subfolders.
#' @param convertFrom The format/vendor of files to be found and converted.
#' Possible entries are: \emph{thermo}, \emph{bruker}, \emph{agilent}, \emph{ab} (from AB Sciex) and \emph{waters}.
#' @param centroidData Logical, set to \code{TRUE} to convert profile data into centroided. The default and recommended is TRUE.
#' @param outPath The path to store the mzML files. When \code{NULL} the \code{path} is used instead.
#'
#' @return The converted files will be saved as mzML in the given path.
#'
#' @references \insertRef{Helmus2021}{ntsIUTA}
#'
#' @export
#'
#' @importFrom patRoon convertMSFiles
#'
#' @examples
#'
mzMLconverter <- function(path = base::getwd(),
                          files = NULL,
                          convertFrom = "agilent",
                          centroidData = TRUE,
                          outPath = NULL) {

  if (base::is.null(files)) {
    fileType <- NULL
    if (convertFrom == "agilent") fileType <- ".\\.d$"
    if (convertFrom == "thermo") fileType <- ".\\.RAW$"
    if (convertFrom == "ab") fileType <- ".\\.wiff$"
    if (convertFrom == "water") fileType <- ".\\.RAW$"

    if (!base::is.null(fileType)) {
      rawFiles <- base::list.files(path = path, pattern = fileType,
                                   recursive = TRUE, full.names = TRUE,
                                   no.. = FALSE, include.dirs = TRUE, ignore.case = TRUE)
    }

  } else {
    rawFiles == files
    # TODO check the file format to update/validate convertFrom when NULL
  }

  if (base::length(rawFiles) > 1) {
    if (centroidData) {
        #converts raw profile data into centroided mzML, with reduced space.
        # TODO add possibility to use other method than pwiz for conversion.
        patRoon::convertMSFiles(files = rawFiles,
                                outPath = base::ifelse(base::is.null(outPath), path, outPath),
                                dirs = FALSE,
                                anaInfo = NULL,
                                from = convertFrom,
                                to = "mzML",
                                overWrite = FALSE,
                                algorithm = "pwiz",
                                centroid = "vendor",
                                filters = c("msLevel 1-2"),
                                extraOpts = NULL,
                                PWizBatchSize = 1)
    } else {
      patRoon::convertMSFiles(files = rawFiles,
                                  outPath = base::ifelse(base::is.null(outPath), path, outPath),
                                  dirs = FALSE,
                                  anaInfo = NULL,
                                  from = convertFrom,
                                  to = "mzML",
                                  overWrite = FALSE,
                                  algorithm = "pwiz",
                                  centroid = NULL,
                                  filters = NULL,
                                  extraOpts = NULL,
                                  PWizBatchSize = 1)
    }
  } else {
    base::print("No files found with the given format or vendor!
                Check if the files are in the folder or see documentation for the possible formats.")
  }
}
