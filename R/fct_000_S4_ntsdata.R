

#' @title ntsData
#' @description S4 class object to organize and store processed data
#' within the \pkg{ntsIUTA} package.
#'
#' @slot title A character string with the project title.
#' @slot info A list to store project details.
#' The first position is for description of the project.
#' @slot path A character string with the project path.
#' as defined with \code{\link{setupProject}}.
#' @slot date The project date.
#' @slot polarity A string character defining the polarity mode of
#' the MS files in the \linkS4class{ntsData} object.
#' Possible values are "positive" or "negative".
#' @slot samples A \code{data.frame} as obtained by \code{\link{setupProject}}.
#' @slot metadata A \code{data.frame} with the same number of rows
#' as the \code{samples} containing metadata to support data interpretation.
#' @slot algorithms A list of algorithms used for the basic workflow steps,
#' which are \emph{Peak Picking}, \emph{Make Features} and \emph{Annotation}.
#' @slot parameters A list containing process parameters for the workflow steps.
#' @slot QC Slot for assigning the QC sample replicate group and results.
#' Note that the assigned group is not included in the basic workflow
#' but only used for quality control, using the function \code{\link{checkQC}},
#' and for optimization of workflow parameters. A screening list with target substances
#' must be provided for running quality control.
#' @slot MSnExp An \linkS4class{OnDiskMSnExp} as generated by \code{\link{setupProject}}.
#' @slot patdata A \linkS4class{features} or \linkS4class{featureGroups}
#' object derived from the basic NTS workflow
#' (peak picking, alignment and grouping).
#' @slot peaks A list with a data.frame containing the peak information
#' for each sample in the slot \code{samples}.
#' same length as number of rows with peak information.
#' @slot features data.frame.
#' @slot annotation Slot for storage of annotation of isotopes and adducts and
#' source fragments. Features with similar chromatographic behaviour
#' are grouped by components. Isotopologues are grouped by \code{isonumber} and
#' are created for each sample replicate group. Similarly, adducts are searched
#' for each sample replicate group and share the same molecular ion (\code{Mion}).
#' The functionality of the package \pkg{CAMERA} was adapted to work better for
#' environmental analyses, where sample replicate groups are, in principle,
#' very different from each other. When specified other functionalities
#' from the package \pkg{patRoon} can be used but the default
#' is the package \pkg{CAMERA} directly. The slot is composed of a list of length 2,
#' where the first entry is a data frame with summarized results for each feature
#' and the second is the raw data from the \pkg{CAMERA} package.
#' @slot control Slot to store the list of internal standards (IS) and the results
#' from IS control of the samples in the \code{ntsData} object.
#' @slot workflows A list of objects inherent of downstream workflows, such as
#' suspect screening.
#'
#' @return An S4 class object named \linkS4class{ntsData}.
#'
#' @note Slot \code{MSnExp} is used to save the \linkS4class{OnDiskMSnExp}
#' object obtained by \pkg{MSnbase} during the \code{\link{setupProject}}.
#' Slot \code{patdata} will contain the object \linkS4class{features} or
#' \linkS4class{featureGroups} generated from the \pkg{patRoon} package.
#' Both objects can be used within native functions of \pkg{MSnbase} and
#' \pkg{patRoon}.
#'
#' @export
#'
#' @examples
#'
setClass("ntsData",
  slots = c(
    title = "character",
    info = "list",
    path = "character",
    date = "Date",
    polarity = "character",
    samples = "data.frame",
    metadata = "data.frame",
    algorithms = "list",
    parameters = "list",
    QC = "list",
    MSnExp = "OnDiskMSnExp",
    patdata = "workflowStep",
    peaks = "data.frame",
    features = "data.frame",
    annotation = "list",
    control = "list",
    workflows = "list"
  ),
  prototype = list(
    title = "New Project",
    info = list(description = NA_character_,
                history = list()),
    path = NA_character_,
    date = Sys.Date(),
    polarity = "positive",
    samples = data.frame(file = character(),
                         sample = character(),
                         group = character(),
                         blank = character()),
    metadata = data.frame(sample = character()),
    algorithms = list(peakPicking = NA_character_,
                      makeFeatures = NA_character_,
                      annotation = NA_character_),
    parameters = list(peakPicking = list(),
                      peakAlignment = list(),
                      peakGrouping = list(),
                      fillMissing = list(),
                      annotation = list()),
    QC = list(samples = data.frame(file = character(),
                                   sample = character(),
                                   group = character(),
                                   blank = character()),
              targets = data.frame(),
              data = list(),
              results = data.frame()),
    MSnExp = new("OnDiskMSnExp"),
    patdata = new("featuresXCMS3"),
    peaks = data.frame(),
    features = data.frame(),
    annotation = list(comp = data.frame(),
                      raw = list()),
    control = list(standards = data.frame(),
                   results = data.frame()),
    workflows = list()
  )
)


### show -----

#' @describeIn ntsData Informative printing.
#'
#' @param object An \linkS4class{ntsData} object.
#'
#' @export
#' @importFrom dplyr count
setMethod("show", "ntsData", function(object) {

  st <- object@samples[, c("sample", "group", "blank")]
  if (nrow(object@peaks) > 0) {
    st$peaks <- count(object@peaks, sample)$n
  }

  cat(is(object)[[1]], "\n",
      "  Project: ", object@title, "\n",
      "  Date:  ", as.character(object@date), "\n",
      "  Path:  ", object@path, "\n",
      "  Polarity:  ", object@polarity, "\n",
      "  Sample details:  ", "\n", "\n", sep = "")

  if (nrow(st) > 0) rownames(st) <- 1:nrow(st)

  print(st)

  cat("\n")

  cat("  QC samples:  ",
      ifelse(nrow(object@QC$samples) < 1, "empty", paste(object@QC$samples$sample, collapse = ", ")),
      "\n", " QC results:  ",
      ifelse(length(object@QC$results) < 1, "empty", "to add list of result objects"),
      "\n", set = "")

  cat("\n")

  cat("  Algorithms:  ", "\n",
      "    ", "Peak Picking: ", ifelse(!is.na(object@algorithms$peakPicking),
                                       object@algorithms$peakPicking,
                                       "empty"), "\n",
      "    ", "Make Features: ", ifelse(!is.na(object@algorithms$makeFeatures),
                                        object@algorithms$makeFeatures,
                                        "empty"), "\n",
      "    ", "Annotation: ", ifelse(!is.na(object@algorithms$annotation) > 0,
                                     object@algorithms$annotation,
                                     "empty"), "\n",
      sep = ""
  )

  cat("\n")

  cat("  Parameters:  ", "\n",
      "    ", "Peak Picking: ", ifelse(length(object@parameters$peakPicking) > 0,
                                       class(object@parameters$peakPicking),
                                       "empty"), "\n",
      "    ", "Alignment: ", ifelse(length(object@parameters$peakAlignment) > 0,
                                    ifelse(length(object@parameters$peakAlignment) == 1,
                                           class(object@parameters$peakAlignment),
                                           class(object@parameters$peakAlignment[[1]])),
                                    "empty"), "\n",
      "    ", "Grouping: ", ifelse(length(object@parameters$peakGrouping) > 0,
                                   class(object@parameters$peakGrouping),
                                   "empty"), "\n",
      "    ", "Filling: ", ifelse(length(object@parameters$fillMissing) > 0,
                                  class(object@parameters$fillMissing),
                                  "empty"), "\n",
      "    ", "Annotation: ", ifelse(length(object@parameters$annotation) > 0,
                                  class(object@parameters$annotation),
                                  "empty"), "\n",
      sep = ""
  )

  cat("\n")

  cat("  MSnExp spectra:  ", length(object@MSnExp), "\n",
      "  MS level(s):  ", ifelse(length(object@MSnExp) > 0,
                                 paste(sort(unique(msLevel(object@MSnExp))), collapse = ", "),
                                 "-"), "\n",
      "  patRoon-class:  ", ifelse(length(object@patdata) > 0,
                                   class(object@patdata), "empty"), "\n",
      sep = ""
  )

  if (nrow(object@features) > 0) {
    cat("\n")
    cat(" Number of features:  ", nrow(object@features), "\n", sep = "")
  }

})



### samples -----

#' @describeIn ntsData Getter for samples.
#'
#' @param object An \linkS4class{ntsData} object.
#'
#' @export
setMethod("samples", "ntsData", function(object) object@samples$sample)




### sampleGroups -----

#' @describeIn ntsData Getter for sample replicate groups.
#'
#' @param object An \linkS4class{ntsData} object.
#'
#' @export
#'
setMethod("sampleGroups", "ntsData", function(object) object@samples$group)

#' @describeIn ntsData Setter for sample replicate groups.
#'
#' @param object An \linkS4class{ntsData} object.
#' @param value A character vector to assign sample replicate groups.
#'
#' @export
#'
setMethod("sampleGroups<-", signature("ntsData", "ANY"), function(object, value) {

  if (length(value) != length(object@samples$sample)) {
    stop("Length of value does not match the number of samples.")
  }

  object@samples$group <- value

  return(object)
})




### blanks -----

#' @describeIn ntsData Getter for blank replicate groups.
#'
#' @param object An \linkS4class{ntsData} object.
#'
#' @export
#'
setMethod("blanks", "ntsData", function(object) object@samples$blank)

#' @describeIn ntsData Setter for blank replicate groups.
#'
#' @param object An \linkS4class{ntsData} object.
#' @param value A character vector with the name/s of the blank sample replicate group/s.
#' If more than one, the length of \code{value} should be equal to
#' the number of samples.
#'
#' @export
#'
setMethod("blanks<-", signature("ntsData", "ANY"), function(object, value) {

  if (FALSE %in% unique(value %in% object@samples$group)) {
    error("Blank replicate sample groups must be one or more sample replicate groups.")
  }

  object@samples$blank <- value

  return(object)
})




### QC -----

#' @describeIn ntsData Getter for QC replicate sample groups.
#'
#' @param object An \linkS4class{ntsData} object.
#'
#' @export
#'
setMethod("QC", "ntsData", function(object) object@QC$samples$sample)


#' @describeIn ntsData Setter for QC replicate sample groups.
#'
#' @param object An \linkS4class{ntsData} object.
#' @param value A character vector with the names of the sample replicate group/s
#' to be used for QC.
#'
#' @export
#'
setMethod("QC<-", "ntsData", function(object, value) {

  if (FALSE %in% unique(value %in% object@samples$group)) {
    cat("Sample replicate group/s not found in the sample replicate groups.")
  } else {
    object@QC$samples <- object@samples[object@samples$group %in% value, ]
    object@samples <- object@samples[!(object@samples$group %in% value), ]
  }

  return(object)
})




### [ sub-setting -----

#' @describeIn ntsData Subset on samples, using sample index or name.
#'
#' @param x An \linkS4class{ntsData} object.
#' @param i The indice/s or name/s of the samples to keep in the \code{x} object.
#' @param j Ignored.
#' @param drop Ignored.
#' @param \dots Ignored.
#'
#' @export
#'
#' @importMethodsFrom MSnbase filterFile fileNames
#' @importMethodsFrom xcms filterFile
#'
setMethod("[", c("ntsData", "ANY", "missing", "missing"), function(x, i, ...) {

  if (!missing(i)) {

    if (!is.character(i)) {
      sn <- x@samples$sample[i]
      sidx <- which(x@samples$sample %in% sn)
    } else {
        sn <- i
        sidx <- which(x@samples$sample %in% sn)
    }

    x@samples <- x@samples[x@samples$sample %in% sn,, drop = FALSE]

    x@metadata <- x@metadata[x@metadata$sample %in% sn,, drop = FALSE]

    if (length(x@MSnExp) > 0) x@MSnExp <- MSnbase::filterFile(x@MSnExp, file = sidx)

    if (nrow(x@peaks) > 0) x@peaks <- x@peaks[x@peaks$sample %in% sn,, drop = FALSE]

    if (nrow(x@features) > 0) {

      #To be replaced when sub-setting in patRoon is fixed
      x@patdata <- filterFeatureGroups(x@patdata, i = sidx)

      x <- buildFeatureList(x)

    } else {

      #subset patRoon object without featureGroups
      if (length(x@patdata) > 0) {
        x@patdata@features <- x@patdata@features[sidx]
        x@patdata@analysisInfo <- x@patdata@analysisInfo[x@patdata@analysisInfo$analysis %in% sn, ]
        if (x@patdata@algorithm == "xcms3") {
          files <- basename(fileNames(x@patdata@xdata)[sidx])
          x@patdata@xdata <- filterFile(x@patdata@xdata, files)
        }
      }
    }

    #annotation, remove replicate groups without samples
    if (nrow(x@annotation$comp) > 0) {
      rg <- unique(x@samples$group)
      x@annotation$comp <- x@annotation$comp[x@annotation$comp$group %in% rg, ]
      x@annotation$raw <- x@annotation$raw[names(x@annotation$raw) %in% rg]
      if (nrow(x@features) > 0) x@annotation$comp <- x@annotation$comp[x@annotation$comp$ID %in% x@features$ID, ]
    }
  }

  return(x)

})




### peaks -----

#' @describeIn ntsData Getter for chromatographic peaks.
#'
#' @param object An \linkS4class{ntsData} object.
#' @param fileIndex The indices of samples to keep in the \code{object}.
#' @param ID The ID of peaks of interest.
#' @param mz Alternatively to \code{ID}, the \emph{m/z} of interest to find peaks.
#' Can be of length two, defining a mass range to find peaks.
#' @param ppm The mass deviation, in ppm, of a given \code{mz}.
#' @param rt The retention time to find peaks.
#' @param rtWindow The time deviation. Can be of length two, defining a time range.
#' @param rtUnit The unit of the time arguments. Possible values are "sec" and "min".
#'
#' @export
#'
#' @importFrom checkmate assertSubset
#' @importFrom dplyr filter between
#'
setMethod("peaks", "ntsData", function(object,
                                       fileIndex = NULL, ID = NULL,
                                       mz = NULL, ppm = 20,
                                       rt = NULL, rtWindow = NULL,
                                       rtUnit = "sec") {

  if (nrow(object@peaks) == 0) return(object@peaks)

  if (!missing(fileIndex)) object <- filterFileFaster(object, fileIndex)

  if (missing(ID)) ID <- NULL

  if (missing(mz)) mz <- NULL

  rtr <- NULL

  if (!is.null(ID)) {
    pk <- object@peaks[object@peaks$ID %in% ID, ]
  } else {
    if (!is.null(mz)) {
      if (missing(rt)) rt <- NULL
      if (missing(rtWindow)) rtWindow <- NULL
      if (missing(rtUnit)) rtUnit <- "sec"
      if (missing(ppm)) ppm <- 20
      assertSubset(rtUnit, c("sec", "min"))
      mzr <- mzrBuilder(mz = mz, ppm = ppm)
      rtr <- rtrBuilder(rt = rt, rtWindow = rtWindow, rtUnit = rtUnit)
      pk <- dplyr::filter(object@peaks,
                          between(mz, mzr[1], mzr[2]),
                          between(rt, rtr[1], rtr[2]))
    } else {
      return(cat("One of ID or mz should be given."))
    }
  }

  return(pk)

})




### features -----

#' @describeIn ntsData Getter for features (i.e., grouped peaks).
#'
#' @param object An \linkS4class{ntsData} object.
#' @param fileIndex The indices of samples to keep in the \code{object}.
#' @param ID The ID of features of interest.
#' @param mz Alternatively to \code{ID}, the \emph{m/z} of interest.
#' can be of length two, defining a mass range.
#' @param ppm The mass deviation, in ppm, of a given \code{mz}.
#' @param rt The retention time to find features.
#' @param rtWindow The time deviation. Can be of length two, defining a time range.
#' @param rtUnit The unit of the time arguments. Possible values are "sec" and "min".
#'
#' @export
#'
#' @importFrom checkmate assertSubset
#' @importFrom dplyr filter between
#'
setMethod("features", "ntsData", function(object,
                                          fileIndex = NULL, ID = NULL,
                                          mz = NULL, ppm = 20,
                                          rt = NULL, rtWindow = NULL,
                                          rtUnit = "sec") {

  if (nrow(object@features) == 0) return(object@features)

  if (missing(ID)) ID <- NULL

  if (missing(mz)) mz <- NULL

  if (!missing(fileIndex)) object <- filterFileFaster(object, fileIndex)

  rtr <- NULL

  if (!is.null(ID)) {
    ft <- object@features[object@features$ID %in% ID, ]
  } else {
    if (!is.null(mz)) {
      if (missing(rt)) rt <- NULL
      if (missing(rtWindow)) rtWindow <- NULL
      if (missing(rtUnit)) rtUnit <- "sec"
      if (missing(ppm)) ppm <- 20
      assertSubset(rtUnit, c("sec", "min"))
      mzr <- mzrBuilder(mz = mz, ppm = ppm)
      rtr <- rtrBuilder(rt = rt, rtWindow = rtWindow, rtUnit = rtUnit)
      ft <- dplyr::filter(object@features,
                          between(mz, mzr[1], mzr[2]),
                          between(rt, rtr[1], rtr[2]))
    } else {
      return(cat("One of ID or mz should be given."))
    }
  }

  return(ft)

})




### components -----

#' @describeIn ntsData Getter for components (i.e., annotated features).
#'
#' @param object An \linkS4class{ntsData} object.
#' @param samples The indice/s or name/s of samples to keep in the \code{object}.
#' @param ID The ID of features of interest.
#' @param mz Alternatively to \code{ID}, the \emph{m/z} of interest.
#' can be of length two, defining a mass range.
#' @param ppm The mass deviation, in ppm, of a given \code{mz}.
#' @param rt The retention time to find features.
#' @param rtWindow The time deviation. Can be of length two, defining a time range.
#' @param rtUnit The unit of the time arguments. Possible values are "sec" and "min".
#' @param compNumber Alternatively, the component number to find features.
#' @param entireComponents Logical, set to \code{TRUE} to extract all features
#' from the represented components.
#' @param onlyAnnotated Logical, set to \code{TRUE} to extract only annotated features.
#' @param onlyRelated Logical, set to \code{TRUE} to extract only features that are related
#' to the features of interest.
#'
#' @export
#'
#' @importFrom checkmate assertSubset
#' @importFrom dplyr filter between
#' @importFrom stats na.omit
#'
setMethod("components", "ntsData", function(object,
                                            samples = NULL,
                                            ID = NULL,
                                            mz = NULL, ppm = 5,
                                            rt = NULL, rtWindow = 1, rtUnit = "sec",
                                            compNumber = NULL,
                                            entireComponents = TRUE,
                                            onlyAnnotated = FALSE,
                                            onlyRelated = TRUE) {

  if (missing(samples)) samples <- NULL

  if (missing(ID)) ID <- NULL

  if (missing(mz)) mz <- NULL

  if (missing(compNumber)) compNumber <- NULL

  comp <- object@annotation$comp

  if (nrow(comp) == 0) return(comp)

  #filter for a replicate group or for all
  if (!is.null(samples)) {
    if (!is.null(samples)) {
      if (is.character(samples)) {
        rg <- unique(object@samples$group[object@samples$sample %in% samples])
      } else {
        rg <- unique(object@samples$group[samples])
      }
      comp <- comp[comp$group %in% rg, ]
    }
  }

  if (!is.null(ID)) {
    comp <- comp[comp$ID %in% ID, ]
  } else {
    #When ID is NULL but specified by mz +/- ppm
    if (!is.null(mz)) {
      if (missing(rt)) rt <- NULL
      if (missing(rtWindow)) rtWindow <- NULL
      if (missing(rtUnit)) rtUnit <- "sec"
      if (missing(ppm)) ppm <- 20
      assertSubset(rtUnit, c("sec", "min"))
      mzr <- mzrBuilder(mz = mz, ppm = ppm)
      rtr <- rtrBuilder(rt = rt, rtWindow = rtWindow, rtUnit = rtUnit)
      comp <- dplyr::filter(comp,
                            between(mz, mzr[1], mzr[2]),
                            between(rt, rtr[1], rtr[2]))
    } else {
      #When only the comp number is given
      if (!is.null(compNumber)) {
        comp <- comp[comp$comp %in% compNumber, ]
      }
    }
  }

  if (nrow(comp) == 0) return(comp)

  comp2 <- comp

  if (!missing(entireComponents)) {
    if (entireComponents) comp2 <- object@annotation$comp[object@annotation$comp$comp %in% comp2$comp, ]
  }

  #filter ano by selecting only annotated Features
  if (!missing(onlyAnnotated)) {
    if (onlyAnnotated) comp2 <- comp2[!is.na(comp2$Mion) | !is.na(comp2$adductMion), ]
  }

  if (!missing(onlyRelated)) {
    if (onlyRelated) comp2 <- comp2[comp2$Mion %in% stats::na.omit(comp$Mion) | comp2$adductMion %in% stats::na.omit(comp$adductMion), ]
  }

  return(comp2)

})
