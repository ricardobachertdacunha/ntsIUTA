


#' @title peakPicking
#' @description Extracts chromatographic peaks from centroided \linkS4class{OnDiskMSnExp} and returns a \code{list} of \linkS4class{XCMSnExp}
#' objects for each replicate sample group as defined in the \code{\link{projectSetup}} function.
#' The \linkS4class{XCMSnExp} objects can be conconated via \code{c()} function of the \pkg{xcms} package.
#' We separate the peaks from each replicate group to facilitate workflows that include multi-project cross-analysis.
#' The peak picking uses the function \code{\link[xcms]{chromatographic-peak-detection}} from the \pkg{xcms} package.
#' Different methods for peak picking can be used. For more information, see documentation of \code{\link[xcms]{chromatographic-peak-detection}}.
#' 
#' 
#' @param rawData The \linkS4class{OnDiskMSnExp} object generated by the \code{\link{importRawData}} function.
#' @param param The parameters for the choosen peak picking method.
#' See documentation of \code{\link[xcms]{chromatographic-peak-detection}} for more information.
#' @param removeQC Logical, set to \code{TRUE} to remove replicate groups in the \code{rawData} named 'QC'.
#' @param refinePeaks Logical, set to \code{TRUE} to refine peaks.
#' @param expandRt Time (in seconds) to expand the peak width to merge neighboring peaks.
#' @param minProp The proportion (between 0 and 1) representing the proporion of intensity to be required for peaks to be joined.
#' @param expandMz Decreases the minimum and increases the maximum \emph{m/z} by a fixed given value.
#' @param ppm Decreases the minimum and increases the maximum \emph{m/z} by a fixed given value, in ppm.
#' @param maxPeakwidth The maximum width allowed for a peak, in seconds.
#' @param save Logical, set to \code{TRUE} to save the generated list of \code{XCMSnExp} objects in the disk.
#' @param projPath The \code{projPath} directory as defined in the \code{setup} object.
#' @param maxMultiProcess Logical, set to \code{TRUE} to enable max parallel processing. Changes the number of workers to the maximum available.
#'
#' @return A \code{list} of \linkS4class{XCMSnExp} objects with length equal to the number of replicate groups defined in the \code{setup}.
#' The \code{list} is named with the name given to the sample replicate groups.
#' 
#' @note See parameters in \code{?refineChromPeaks} from \code{xcms} for more information when \code{refinePeaks} is set to \code{TRUE}.
#' 
#' @references
#' \insertRef{MSnbase1}{ntsIUTA}
#' \insertRef{MSnbase2}{ntsIUTA}
#' \insertRef{xcms1}{ntsIUTA}
#' \insertRef{xcms2}{ntsIUTA}
#' \insertRef{xcms3}{ntsIUTA}
#' 
#' @export
#' 
#' @importFrom BiocParallel registered SnowParam register bpparam
#' @importFrom parallel detectCores
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @importFrom xcms findChromPeaks MergeNeighboringPeaksParam refineChromPeaks CleanPeaksParam
#' @importFrom MSnbase filterFile
#' 
#'
#' @examples
#' 
#' 
#' 
peakPicking <- function(rawData = rawData, param = NULL, removeQC = TRUE,
                        refinePeaks = FALSE, expandRt = 1, minProp = 0.9, expandMz = 0, ppm = 0,
                        maxPeakwidth = NULL,
                        save = TRUE, projPath = setup$projPath, maxMultiProcess = TRUE) {
  
  library(xcms)
  
  #Examples
  #setup <- ntsIUTA::projectSetup(projPath = system.file(package = "ntsIUTA", dir = "extdata"), save = FALSE)
  # rawDataExample <- ntsIUTA::importRawData(setup$sampleInfo[1:3,], save = FALSE, centroidedData = TRUE)
  # 
  # #Obtained by the function MassifquantParam from the xcms packeage, but other options for param are possible.
  # param <- xcms::MassifquantParam(ppm = 30, peakwidth = c(8, 30), snthresh = 10, prefilter = c(6, 1000), mzCenterFun = "wMean",
  #                                 integrate = 1, mzdiff = -0.001, fitgauss = TRUE, noise = 350, criticalValue = 2.5, consecMissedLimit = 2,
  #                                 unions = 1, checkBack = 0, withWave = TRUE, verboseColumns = TRUE)
  #                                 
  # peaksDataExample <- ntsIUTA::peakPicking(rawDataExample, param = param, save = FALSE)
  # peaksDataExample
  
  #Enable full parallel processing
  if (maxMultiProcess)
  {
    snow <- BiocParallel::registered("SnowParam")
    if (snow$workers < parallel::detectCores())
    {
      snow <- BiocParallel::SnowParam(workers = parallel::detectCores(), type = "SOCK", exportglobals = FALSE)
      BiocParallel::register(snow, default = TRUE)
    }
  }
  
  #Divide by replicate groups in rawData
  groups <- base::unique(rawData$sample_group)
  
  #Remove QC replicate group from experiment
  if (removeQC) groups <- groups[!base::grepl("qc|QC", groups)]
  
  
  peaksData <- base::list()
  
  #Make peaksData by replicate groups as defined in the setup experiment
  pb <- utils::txtProgressBar(min = 0, max = 100, initial = 0, char = "=", width = 80, style = 3)
  for (rgidx in 1:base::length(groups))
  {
    
    sampleidxs <- base::which(rawData$sample_group == groups[rgidx])
    
    #TODO add possibility to run patRoon peakpicking functions and convert to XCMSnExp object
    #Other methods for peak picking with xcms possible by changing param
    peaksData[[groups[rgidx]]] <- xcms::findChromPeaks(MSnbase::filterFile(rawData, sampleidxs),
                                                       return.type = "XCMSnExp",
                                                       msLevel = 1, BPPARAM = BiocParallel::bpparam("SnowParam"),
                                                       param = param)
    
    
    if (refinePeaks)
    {
      mpp <- xcms::MergeNeighboringPeaksParam(expandRt = expandRt, minProp = minProp, expandMz = expandMz, ppm = ppm)
      peaksData[[groups[rgidx]]] <- xcms::refineChromPeaks(peaksData[[groups[rgidx]]],
                                                           mpp, msLevel = 1, BPPARAM = BiocParallel::bpparam("SnowParam"))
      if (!base::is.null(maxPeakwidth)) 
      {
        peaksData[[groups[rgidx]]] <- xcms::refineChromPeaks(peaksData[[groups[rgidx]]],
                                                       param = xcms::CleanPeaksParam(maxPeakwidth = maxPeakwidth),
                                                       msLevel = 1L, BPPARAM = BiocParallel::bpparam("SnowParam"))
      }
    }
    
    
    utils::setTxtProgressBar(pb, ((rgidx/base::length(groups))*100))
  }
  
  
  if (save)
  {
    rData <- base::paste0(projPath,"\\rData")
    if (!base::dir.exists(rData)) base::dir.create(rData)
    base::saveRDS(peaksData, file = base::paste0(rData,"\\peaksData.rds"))
  }
  
  return(peaksData)
  
}


